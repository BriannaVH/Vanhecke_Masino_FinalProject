<html>

<head>
    <title>Three.js Geometries Example w/ Vertex Shader</title>
</head>

<body>

    <canvas id="myCanvas" width="1000" height="500"></canvas>
    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { OrbitControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js'


        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        const controls = new OrbitControls(camera, renderer.domElement);
        let loader = new THREE.TextureLoader();


    

        function random(min, max) {
            let num = Math.random() * max + min;
            let rand = Math.random();
            if (rand > .5) {
                num *= -1;
            }
            return num;
        }




        function Particle() {
            this.origin = new THREE.Vector3(random(0, 2), 0, random(0, 2));
            this.speed = Math.random()*2;
            this.mass = Math.random() * maxSize + minSize;
            this.direction = new THREE.Vector3(random(0, spread), (Math.random() * 2 + 1) / (this.mass * modulator), random(0, spread));


            this.geometry = new THREE.SphereGeometry(this.mass / scaler, 16, 16);
            this.material = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], opacity: .5, transparent: true });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.position.set(this.origin.x, this.origin.y, this.origin.z);
            scene.add(this.mesh);
        }


        function createLog(rotationSide) {
            const geometry = new THREE.CylinderGeometry(5, 5, 30, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x964B00, map: loader.load("wood/wood.jpg") }); //
            const cylinder = new THREE.Mesh(geometry, material);

            if (rotationSide == 1) {
                cylinder.rotation.z = 1.4;
            }
            else {
                cylinder.rotation.x = 1.6;
            }
            scene.add(cylinder);
        }


        let points = [];
        let spread = .01;
        let limit = 1000;
        let minSize = 1;
        let maxSize = 10;
        let scaler = 3;
        let hBounds = 5;
        let vBounds = 40;
        let modulator = 5;
        let colors = [0xF13811, 0xF69915];

        let delta = 0;
        let switcher = 0;
        let clock = new THREE.Clock();

        createLog(1);
        createLog(2);


      

        function animate() {
            delta = clock.getDelta();
            switcher += delta;
            //console.log(switcher);
            controls.update();
            if (points.length < limit) {
                let sphere = new Particle();
                points.push(sphere);
            }
            if (points.length > 0) {
                for (let i = 0; i < points.length; i++) {
                    //console.log(points[i].mesh);
                    points[i].mesh.translateY(points[i].direction.y * points[i].speed);

                    if (switcher > .01) {
                        points[i].mesh.translateX(points[i].direction.x * -1);
                        points[i].mesh.translateZ(points[i].direction.z);
                        switcher = 0;
                    }

                    points[i].mesh.translateX(points[i].direction.x);
                    points[i].mesh.translateZ(points[i].direction.z * -1);

                    //|| Math.abs(points[i].mesh.position.x) > hBounds * .85 || Math.abs(points[i].mesh.position.z) > hBounds * .85
                    if (points[i].mesh.position.y > vBounds * .7 || Math.abs(points[i].mesh.position.x) > hBounds * .85 || Math.abs(points[i].mesh.position.z) > hBounds * .85) {
                        points[i].mesh.material.color.set(0xF69915);
                    }

                    //console.log(points[i]);
                    //if (points[i].mesh.position.y > vBounds - points[i].mass || Math.abs(points[i].mesh.position.x) > hBounds - points[i].mass || Math.abs(points[i].mesh.position.z) > hBounds - points[i].mass) {
                    if (points[i].mesh.position.y > vBounds - points[i].mass * scaler || Math.abs(points[i].mesh.position.x) > hBounds || Math.abs(points[i].mesh.position.z) > hBounds) {
                        //console.log(points[i].origin);
                        //console.log(points[i].mesh);
                        points[i].mesh.position.set(points[i].origin.x, points[i].origin.y, points[i].origin.z);
                        //console.log(points[i].mesh);
                        if (Math.random() > .5) {
                            points[i].mesh.material.color.set(0xF13811);    
                        }
                        else{
                            points[i].mesh.material.color.set(0x800000);
                        }
                    }
                }
            }

            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
        renderer.render(scene, camera);
    </script>
</body>

</html>