<html>

<head>
    <title>Three.js Geometries Example w/ Vertex Shader</title>
</head>

<body>

    <canvas id="myCanvas" width="1000" height="500"></canvas>
    <script type="module">
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";

        var scene = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        camera.position.z = 150;
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);




        let loader = new THREE.TextureLoader();
        let fire = new THREE.MeshBasicMaterial({ map: loader.load("skies/fire.jpg"), opacity: .5, transparent: true });


        let points = [];
        let spread = .05;
        let colors = [0xF13811, 0xF69915];
        let hSpread = 10;
        let pointSize = 1;

        function makePoint() {
            let xCoord = Math.random() * hSpread;
            let yCoord = 0;
            let zCoord = Math.random() * hSpread;

            let Zrandomizer = Math.random();
            let Xrandomizer = Math.random();

            this.xVal = Math.random() * spread;
            this.zVal = Math.random() * spread;

            this.geometry = new THREE.SphereGeometry(pointSize, 16, 16);
            // this.material = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * 2)] });
            this.material = fire;
            this.shape = new THREE.Mesh(this.geometry, this.material);
            this.shape.position.set(xCoord, yCoord, zCoord);
            this.originalPosition = new THREE.Vector3(xCoord, yCoord, zCoord);
            if (Zrandomizer > .5) {
                this.zVal = this.zVal * -1;
            }
            if (Xrandomizer > .5) {
                this.xVal = this.xVal * -1;
            }
            scene.add(this.shape);
        }


        function calcPointDistance(point, point2) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - point2.x) * (point.x - point2.x) +
                (point.y - point2.y) * (point.y - point2.y) +
                (point.z - point2.z) * (point.z - point2.z)
            )
            return distance; //Returns distance
        }


        let limit = 50;
        let numPoints = 10000;
        let speed = 3;
        let density = 5;


        function animate() {
            if (points.length < numPoints) {
                for (let i = 0; i < density; i++) {
                    let newPoint = new makePoint();
                    points.push(newPoint);
                }

            }

            for (let i = 0; i < points.length; i++) {
                for (let s = 0; s < speed; s++) {
                    points[i].shape.translateZ(points[i].zVal);
                    points[i].shape.translateX(points[i].xVal);
                    points[i].shape.translateY(.2);
                }

                if (calcPointDistance(points[i].shape.position, points[i].originalPosition) > limit) {
                    scene.remove(points[i].shape);
                    points[i].material.dispose();
                    points[i].geometry.dispose();
                    const index = points.indexOf(points[i]);
                    if (index > -1) {
                        points.splice(index, 1);
                    }
                }
            }
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();
        renderer.render(scene, camera);
    </script>
</body>

</html>