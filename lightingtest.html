<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - lightning strike</title>

</head>

<body>
    <canvas id="myCanvas" width="800" height="800"></canvas>

    <!-- <div id="container"></div> -->


    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->



    <script type="module">


        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        //import Stats from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/libs/stats.module.js';

        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';
        import { LightningStrike } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/geometries/LightningStrike.js';
        import { LightningStorm } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/objects/LightningStorm.js';


        //Variable Declaration
        import { OutlinePass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/OutlinePass.js'
        import { RenderPass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/RenderPass.js'
        import { EffectComposer } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/EffectComposer.js'
        import { OrbitControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/OrbitControls.js';
        
        
        
        //import { GUI } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/libs/dat.gui.module.js';


        // let container;

        let scene = new THREE.Scene();
        const GROUND_SIZE = 1000;
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE), new THREE.MeshLambertMaterial({ color: 0x072302 }));
        ground.rotation.x = - Math.PI * 0.5;

        let renderer, composer;

        let currentSceneIndex = 0;

        let currentTime = 0;


        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 80, 10);
        scene.add(camera);


        renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);//Sets color of renderer
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio); //Sets renderer to the canvas
        renderer.setSize(window.innerWidth, window.innerHeight); //Specifies how much of screen will be rendererd

        renderer.shadowMap.enabled = true; //Enables shadow map
        renderer.shadowMapSoft = true; //Specifies type of shadow
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        composer = new EffectComposer(renderer);



        const clock = new THREE.Clock();

        //const raycaster = new THREE.Raycaster();
        // const mouse = new THREE.Vector2();

        initLightning();
        animate();

        function initLightning() {

            // container = document.getElementById('container');

            window.addEventListener('resize', onWindowResize);


            createStormScene(camera, ground, GROUND_SIZE);


            scene.userData.timeRate = 1;


            scene.userData.lightningColorRGB = [
                scene.userData.lightningColor.r * 255,
                scene.userData.lightningColor.g * 255,
                scene.userData.lightningColor.b * 255
            ];

            scene.userData.outlineColorRGB = [
                scene.userData.outlineColor.r * 255,
                scene.userData.outlineColor.g * 255,
                scene.userData.outlineColor.b * 255
            ];

            //createScene();

        }




        function onWindowResize() {

            scene.userData.camera.aspect = window.innerWidth / window.innerHeight;
            scene.userData.camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            composer.setSize(window.innerWidth, window.innerHeight);

        }



        function animate() {

            requestAnimationFrame(animate);

            render();


        }

        function render() {

            currentTime += scene.userData.timeRate * clock.getDelta();

            if (currentTime < 0) {

                currentTime = 0;

            }

            scene.userData.render(currentTime);

        }

        function createOutline(scene, objectsArray, visibleColor) {

            const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, scene.userData.camera, objectsArray);
            outlinePass.edgeStrength = 2.5;
            outlinePass.edgeGlow = 0.7;
            outlinePass.edgeThickness = 2.8;
            outlinePass.visibleEdgeColor = visibleColor;
            outlinePass.hiddenEdgeColor.set(0);
            composer.addPass(outlinePass);

            scene.userData.outlineEnabled = true;

            return outlinePass;

        }



        //

        function createStormScene(camera, terrain, terrainSize) {

            // scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            scene.userData.canGoBackwardsInTime = false;

            scene.userData.camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 20, 10000);

            // Lights

            scene.add(new THREE.AmbientLight(0x444444));

            // const light1 = new THREE.DirectionalLight(0xffffff, 0.5);
            // light1.position.set(1, 1, 1);
            // scene.add(light1);

            // const posLight = new THREE.PointLight(0x00ffff);
            // posLight.position.set(0, 100, 0);
            // scene.add(posLight);

            // Ground



            scene.userData.camera.position.set(0, 0.2, 1.6).multiplyScalar(GROUND_SIZE * 0.5);


            scene.add(ground);

            // Storm

            scene.userData.lightningColor = new THREE.Color(0xB0FFFF);
            scene.userData.outlineColor = new THREE.Color(0x00FFFF);

            scene.userData.lightningMaterial = new THREE.MeshBasicMaterial({ color: scene.userData.lightningColor });

            const rayDirection = new THREE.Vector3(0, - 1, 0);
            let rayLength = 0;
            const vec1 = new THREE.Vector3();
            const vec2 = new THREE.Vector3();

            scene.userData.rayParams = {

                radius0: 1,
                radius1: 0.5,
                minRadius: 0.3,
                maxIterations: 7,

                timeScale: 0.15,
                propagationTimeFactor: 0.2,
                vanishingTimeFactor: 0.9,
                subrayPeriod: 4,
                subrayDutyCycle: 0.6,

                maxSubrayRecursion: 3,
                ramification: 3,
                recursionProbability: 0.4,

                roughness: 0.85,
                straightness: 0.65,

                onSubrayCreation: function (segment, parentSubray, childSubray, lightningStrike) {

                    console.log("gets in here1");
                    lightningStrike.subrayConePosition(segment, parentSubray, childSubray, 0.6, 0.6, 0.5);

                    // Plane projection

                    rayLength = lightningStrike.rayParameters.sourceOffset.y;
                    vec1.subVectors(childSubray.pos1, lightningStrike.rayParameters.sourceOffset);
                    const proj = rayDirection.dot(vec1);
                    vec2.copy(rayDirection).multiplyScalar(proj);
                    vec1.sub(vec2);
                    const scale = proj / rayLength > 0.5 ? rayLength / proj : 1;
                    vec2.multiplyScalar(scale);
                    vec1.add(vec2);
                    childSubray.pos1.addVectors(vec1, lightningStrike.rayParameters.sourceOffset);

                }

            };



            const storm = new LightningStorm({
               

                size: GROUND_SIZE,
                minHeight: 90,//Determine how low the lightning can generate at
                maxHeight: 200,
                maxSlope: 0.6,
                maxLightnings: 8,

                lightningParameters: scene.userData.rayParams,

                lightningMaterial: scene.userData.lightningMaterial,

            });

            scene.add(storm);
            console.log(storm);

            // Compose rendering

            composer.passes = [];
            composer.addPass(new RenderPass(scene, scene.userData.camera));
            createOutline(scene, storm.lightningsMeshes, scene.userData.outlineColor);

            // Controls

            const controls = new OrbitControls(scene.userData.camera, renderer.domElement);
            controls.target.y = GROUND_SIZE * 0.05;
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            scene.userData.render = function (time) {
                console.log("gets in here2");

                storm.update(time);

                controls.update();

                if (scene.userData.outlineEnabled) {

                    composer.render();

                } else {

                    renderer.render(scene, scene.userData.camera);

                }

            };

            //  return scene;

        }

    </script>

</body>

</html>