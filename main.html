<html>
<!-- Zara Masino & Brianna Van Hecke -->

<head>
    <title>Final Project</title>
    <link href="styling.css" rel="stylesheet"> <!--Links our css styler to the html elements-->
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>


<!-- The screen that comes up during game start, pause, and end -->
<div id="blocker">
</div>

<!-- The start screen with instructions -->
<div id="instructions">
    <h1 style="font-size:60"> Monster&nbsp;Mash</h1>
    <p style="font-size:20px">
        Run&nbsp;from&nbsp;the&nbsp;monster and&nbsp;collect&nbsp;the&nbsp;star&nbsp;shards!<br />
        <br />
        Hide&nbsp;near&nbsp;the&nbsp;safety of&nbsp;the&nbsp;fire, but&nbsp;not&nbsp;too&nbsp;long!<br />
        <br />
        Move:&nbsp;WASD
        <br />
        Flashlight:&nbsp;F
        <br />
        Esc&nbsp;to&nbsp;pause
    </p>
</div>

<!-- The screen when you lose the game -->
<div id="lost" , style="display:none">
    <p style="font-size:60">
        YOU&nbsp;LOST!
    </p>
</div>

<!-- Logic and styling for the drop down button that lists levels and the start button -->
<div class="dropdown" , id="gameControls">
    <div id="selectbutton">
        <select class="greenText" name="difficulty" id="selectButton2"
            onchange="this.className=this.options[this.selectedIndex].className" class="greenText">>
            <option value="easy" class="greenText" value="easy">Easy</option>
            <!--What the drop down options will display -->
            <option value="medium" class="yellowText" value="medium">Medium</option>
            <option value="hard" class="redText" value="hard">Hard</option>
        </select>
    </div>
    <div id="button">
        <button class="button">Start</button>
    </div>
</div>

<!-- Styling for the pause button -->
<div id="unpause" , style="display:none">
    <button class="unPauseButton">Resume Game</button>
</div>



<body>
    <canvas id="myCanvas" width="800" height="800"></canvas> <!-- Creates canvas-->
    <!-- Imports various javascript files and modules -->
    <script src="Perlin.js"></script>
    <script src="/declarations.js"></script>
    <script src="/functions.js"></script>
    <script type="module">

        //Imports from three.js
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';
        import { LightningStrike } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/geometries/LightningStrike.js';
        import { LightningStorm } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/objects/LightningStorm.js';
        import { OutlinePass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/OutlinePass.js';
        import { RenderPass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/RenderPass.js';
        import { EffectComposer } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/EffectComposer.js';
        import { GLTFLoader } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/loaders/GLTFLoader.js';


        // Initializes the scene and camera
        let scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 80, 10);
        scene.add(camera);

        // Initializes the secondary scene  (which will be layered on top of the first)
        //for the stamina bar, hearts, and star collection tracker.
        // This one uses an orthographic camera
        //Src: https://www.evermade.fi/story/pure-three-js-hud/
        var hudCanvas = document.createElement('canvas');
        hudCanvas.width = windowWidth;
        hudCanvas.height = windowHeight;
        var cameraHUD = new THREE.OrthographicCamera(-windowWidth / 2, windowWidth / 2, windowHeight / 2, -windowHeight / 2, 0, 30);
        cameraHUD.layers.enable(1);
        let sceneHUD = new THREE.Scene();
        // Create texture from rendered graphics.
        var hudTexture = new THREE.Texture(hudCanvas)
        hudTexture.needsUpdate = true;
        // Create HUD material.
        var material = new THREE.MeshBasicMaterial({ map: hudTexture });
        material.transparent = true;
        // Create plane to render the HUD. This plane fill the whole screen.
        var planeGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
        var plane = new THREE.Mesh(planeGeometry, material);
        sceneHUD.add(plane);

        //Initializes and customizes the renderer
        let renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);//Sets color of renderer
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio); //Sets renderer to the canvas
        renderer.setSize(window.innerWidth, window.innerHeight); //Specifies how much of screen will be rendererd
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true; //Enables shadow map
        renderer.shadowMapSoft = true; //Specifies type of shadow
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;


        // Initialize variables dependent on threejs
        let perlin = new Perlin(); // used for terrain generation
        let loader = new THREE.TextureLoader(); //Texture loader
        let raycaster = new THREE.Raycaster();
        // Below variables are used in terrain generation
        let peak = 30;
        let smoothing = 200;
        const GROUND_SIZE = 1000;
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE), new THREE.MeshLambertMaterial({ color: 0x072302 }));
        ground.rotation.x = - Math.PI * 0.5;
        let clock = new THREE.Clock();
        let humanGroup = new THREE.Group(); // used for the body
        let monsterGroup = new THREE.Group(); // used for the body
        let heartPositions = [windowWidth - (windowWidth * .78), windowWidth - (windowWidth * .81), windowWidth - (windowWidth * .84)];

        previousPos.push(new THREE.Vector3(0, -200, 0));
        let controls = new PointerLockControls(camera, document.body); //Enables pointerlock controls
        let composer = new EffectComposer(renderer);

        //Below creates more materials with textures
        let wood = new THREE.MeshPhongMaterial({ color: 0x80471C, map: loader.load("trees/oakwood.jpg") });
        let fireMat1 = new THREE.MeshBasicMaterial({ color: 0xff0000, map: loader.load("campfire/fire.jpg"), opacity: .5, transparent: true });
        let fireMat2 = new THREE.MeshBasicMaterial({ color: 0xFFA500, map: loader.load("campfire/fire.jpg"), opacity: .5, transparent: true });
        let fireMaterials = [fireMat1, fireMat2];


        // Creates the logic for when the start button is clicked 
        document.getElementById("button").onclick = function () {
            // Unpause the game
            gamePaused = false;
            // Remove the html elements
            instructions.style.display = 'none';
            blocker.style.display = 'none';
            gameControls.style.display = 'none';
            // Get the value from the drop down button to set the game difficulty
            var e = document.getElementById("selectButton2");
            console.log(e);
            function onChange() { //Set the current level of the game to whatever the user selected
                level = e.value;
                console.log(level);
            }
            e.onchange = onChange;
            onChange();
            // Set the game parameters based on the level that was selected
            initParameters(level);
            controls.lock(); //Locks pointerlock controls 
            animate(); //Start animating the game!
        };

        // Creates the logic for when the resume game button is clicked
        document.getElementById("unpause").onclick = function () {
            // Resume the game and remove the html overlays
            gamePaused = false;
            blocker.style.display = 'none';
            unpause.style.display = 'none';
            controls.lock(); //Locks pointerlock controls upon the user clicking
            animate(); //Start the game!
        };

        document.addEventListener('keydown', onDocumentKeyDown, false); //Adds key handler to the document

        //If the user has not pressed any keys then the boolean determining whether the user is moving should be turned to false
        document.addEventListener('keyup', (event) => {
            moving = false;
        });

        // Adds logic for when the controls are unlocked (applies for whether the user is simply pausing or has won)
        controls.addEventListener('unlock', function () {
            // Pause the heartbeat audio and pause the game
            heartbeatAudio.pause();
            heartbeatAudio.currentTime = 0;
            gamePaused = true;
            // Enter this if statement if the game is still playing or you have won the game
            if (gameState == 0 || gameState == 1) {
                // Bring up the blocker and the resume button after 1 second
                blocker.style.display = 'block';
                setTimeout(() => {
                    unpause.style.display = 'block'; //To prevent users from running into an error where they click
                    //"resume game" too quickly which results in teh contorls not properly working, make the button
                    //not show up for 1 second
                }, 1000)
            }
            // If the user lost the game
            else if (gameState == 2) {
                setTimeout(() => {
                    // Bring up the blocker and losing game html overlay and play the loss sound after 4 seconds
                    blocker.style.display = 'block';
                    lost.style.display = 'block';
                    play('sounds/gameOver/smash.mp3')
                }, 4000)
            }
            // Unlocks the controls
            controls.unlock();
        });


        // A function that creates particles for the campfire
        function Particle(pos) {
            // Create a size for the particle
            this.size = Math.random() * maxPSize + minPSize;
            //Create the geometry, material, and mesh
            this.geometry = new THREE.DodecahedronGeometry(this.size, 0);
            this.material = fireMaterials[Math.floor(Math.random() * fireMaterials.length)];
            //this.material = new THREE.MeshPhongMaterial({ color: fireColors[Math.floor(Math.random() * fireColors.length)], map: loader.load("star/testfire.jpg"), opacity: .5, transparent: true });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            // Turn on shadows, positions the particles, and give them a direction to go in
            this.mesh.castShadow = true;
            this.position = new THREE.Vector3(pos.x + newRandom(0, spawnSpread), pos.y, pos.z + newRandom(0, spawnSpread));
            this.mesh.position.set(this.position.x, this.position.y, this.position.z);
            this.direction = new THREE.Vector3(newRandom(0, sidewaysSpread), Math.random() / this.size * overallSpeed, newRandom(0, sidewaysSpread));
            scene.add(this.mesh);
        }

        // A function that creates a log
        function Log(rotationSide, pos) {
            // Creates a geometry, material, and a mesh (turns on shadows)
            const geometry = new THREE.CylinderGeometry(5, 5, 30, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0x964B00, map: loader.load("campfire/wood.jpg") }); //, map: loader.load("wood/wood.jpg") 
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.castShadow = true;

            //Position the cylinder and rotate accordingly
            cylinder.position.set(pos.x, pos.y, pos.z);
            if (rotationSide == 1) {
                cylinder.rotation.z = 1.4;
            }
            else {
                cylinder.rotation.x = 1.6;
            }
            scene.add(cylinder);
            return cylinder;
        }

        // A function that creates the campfire
        function CampFire(pos, heightLimit) {
            // Tracks the particles, their height, their position, and whether the fire should fade
            this.particles = [];
            this.height = heightLimit;
            this.position = new THREE.Vector3(pos.x, pos.y, pos.z);
            this.fade = false;
            // Adds a light to the fire and position it
            this.light = new THREE.PointLight(0xffff00, 2.5, 100);
            this.light.position.set(this.position.x, this.position.y + 50, this.position.z);
            scene.add(this.light);
            for (let i = 0; i < pCount; i++) {//The for loop creates the particles for the campfire
                let test = new Particle(pos);
                this.particles.push(test);
            }
            // Create the logs
            this.log1 = Log(1, pos);
            this.log2 = Log(2, pos);
        }


        //Function which makes the ending model
        function makeShiba(position) {

            //Instantiate a loader
            const Mloader = new GLTFLoader();
            // Load a glTF resource
            Mloader.load(
                // resource URL
                'shibaModel/scene.gltf',
                // Called when the resource is loaded
                function (gltf) {
                    dog = gltf.scene;
                    dog.scale.set(20, 20, 20);
                    //console.log(dog);
                    scene.add(dog);
                    gltf.animations; // Array<THREE.AnimationClip>
                    gltf.scene; // THREE.Group
                    gltf.scenes; // Array<THREE.Group>
                    gltf.cameras; // Array<THREE.Camera>
                    gltf.asset; // Object
                    gltf.scene.traverse(function (node) { if (node.isMesh) { node.castShadow = true; } });
                    //Sets dogs position
                    dog.position.setX(position.x);
                    dog.position.setY(position.y);
                    dog.position.setZ(position.z);
                }
            );
        }


        // A function that loads the jumpscare models
        function makeModels() {
            //   Instantiate a loader
            const Gloader = new GLTFLoader();
            // Load a glTF resource
            Gloader.load(
                // resource URL
                'MaskModel/scene.gltf',
                // called when the resource is loaded
                function (gltf) {
                    jumpscare1 = gltf.scene;
                    //Scales the model
                    jumpscare1.scale.set(150, 150, 150);
                    scene.add(jumpscare1);
                    gltf.animations; // Array<THREE.AnimationClip>
                    gltf.scene; // THREE.Group
                    gltf.scenes; // Array<THREE.Group>
                    gltf.cameras; // Array<THREE.Camera>
                    gltf.asset; // Object
                    //Sets jumpscares position
                    jumpscare1.position.setX(0);
                    jumpscare1.position.setY(-500);
                    jumpscare1.position.setZ(0);
                }
            );

            //SKULL WITH EYES FALLING OUT
            const Sloader = new GLTFLoader();
            // Load a glTF resource
            Sloader.load(
                // resource URL
                'is_something_wrong/scene.gltf',
                // called when the resource is loaded
                function (gltf) {
                    jumpscare2 = gltf.scene;
                    // Scales the model
                    jumpscare2.scale.set(10, 10, 10);
                    scene.add(jumpscare2);
                    gltf.animations; // Array<THREE.AnimationClip>
                    gltf.scene; // THREE.Group
                    gltf.scenes; // Array<THREE.Group>
                    gltf.cameras; // Array<THREE.Camera>
                    gltf.asset; // Object
                    //Sets jumpscares position
                    jumpscare2.position.setX(0);
                    jumpscare2.position.setY(-500);
                    jumpscare2.position.setZ(0);
                }
            );
        }

        // A function that places the jumpscares
        function placeJumpscares() {
            // For the number of jumpscares you want
            for (let i = 0; i < 8; i++) { //8
                // Gets a random position and then adds that position to the array
                let position = randomizePositions(380, 50); //380 //40
                jumpscarePositions.push(new THREE.Vector3(position.x, position.y, position.z));
            }
        }

        // A function that triggers, places, and removes then jumpscares
        function jumpscare(index) {
            // Update the game state trackers
            inJumpscare = true;
           
            // Turn on the light to ensure the jumpscares can be seen
            light.intensity = 6;
            // Set the scene fog to .003
            scene.fog.density = .003;

            // Initializes values for the jumpscare positioning modifiers
            let dist = 80;
            let lookAtHeight = 50;
            let monsterLookAtHeight = 1;
            let monsterHeight;
            let monster;
            // If the index is -1 (the main monster)
            if (index == -1) {
                spawningIn = true;
                // Choose and play a random monster caught sound
                let index = Math.floor(Math.random() * 4);
                play(caughtSound[index]);
                // Manipulate the conditions so that the player will look towards the correct 
                // part of the monster
                dist = 80;
                lookAtHeight = 50;
                monsterLookAtHeight = 1;
                monsterHeight = 40;
                monster = monsterGroup;
            }
            // If the index is 0 (the clown mask)
            else if (index == 0) {
                // PLay the clown sounds
                play('sounds/jumpscares/clown.mp3');
                // Manipulate the conditions so that the player will look towards the correct 
                // part of the monster
                dist = 30;
                lookAtHeight = 20;
                monsterLookAtHeight = -10;
                monsterHeight = 40;
                monster = jumpscare1;
            }
            // If the index is 1 (the creepy baby)
            else if (index == 1) {
                // Manipulate the conditions so that the player will look towards the correct 
                // part of the monster
                play('sounds/jumpscares/childLaugh.mp3');
                dist = 90;
                lookAtHeight = 0;
                monsterLookAtHeight = 60;
                monsterHeight = 100;
                monster = jumpscare2;
            }
            // Set a timer to hide the monster when the jumpscare is done (4 seconds)
            setTimeout(function () {
                // Update the gamestate tracker
                inJumpscare = false;
                // If the game is not over, move the monster back to the hiding spot
                if (gameState != 2) {
                    monster.position.set(0, -500, 0);
                }
                // Reset the scene fog
                scene.fog.density = 0;
            }, 4000);

            // Raycast at the position of the camera in order to consistently place the monster 50 units above
            //the ground (needed for lookat perspectives)
            let rayHeight = new THREE.Raycaster();
            let rayDirection = new THREE.Vector3(0, -1, 0);//Gives direction for raycaster
            let intersectHeight = rayHeight.intersectObject(terrainShadow); //Finds where the ray intersects with the terrain
            
            // Sets the monsters position to the camera position, shifted slightly in the x direction
            monster.position.set(camera.position.x + dist, camera.position.y, camera.position.z);
            rayHeight.ray.set(monster.position, rayDirection.normalize()); //Has ray cast downwards from the monster position
            let yPos;
            if (intersectHeight.length != 0) {
                yPos = intersectHeight[0].point.y; //Sets the yPos to where the ray intersected with the terrain
            }
            // Add the monsters height to the ypos for consistency 
            monster.position.y = yPos + monsterHeight;
            //Sets the lookat for the player and the monster so they look at each other
            let camlookat = new THREE.Vector3(monster.position.x, monster.position.y + lookAtHeight, monster.position.z);
            camera.lookAt(camlookat);
            jumpscareLookAt = camlookat;
            monster.lookAt(camera.position.x, camera.position.y + monsterLookAtHeight, camera.position.z);
        }

        //Src: https://threejs.org/examples/webgl_lightningstrike.html
        //A function that creates lightning in the scene
        function initLightning() {
            // Calls create storm with the camera and the terrain
            createStormScene(camera, terrain, 450);
            // Sets the scene userdata to be used for the lightning lightning color and outline
            scene.userData.timeRate = 4;
            scene.userData.lightningColorRGB = [
                scene.userData.lightningColor.r * 255,
                scene.userData.lightningColor.g * 255,
                scene.userData.lightningColor.b * 255
            ];
            scene.userData.outlineColorRGB = [
                scene.userData.outlineColor.r * 255,
                scene.userData.outlineColor.g * 255,
                scene.userData.outlineColor.b * 255
            ];
        }

        // A function that creates the outline for the lightning strikes
        function createOutline(scene, objectsArray, visibleColor) {
            // Creates the outlinepass and gives the appropriate parameters
            const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, scene.userData.camera, objectsArray);
            //These all determine the appearance of the outline of the lightning strike
            outlinePass.edgeStrength = 2.5;
            outlinePass.edgeGlow = 0.7;
            outlinePass.edgeThickness = 2.8;
            outlinePass.visibleEdgeColor = visibleColor;
            outlinePass.hiddenEdgeColor.set(0);
            // Adds the outline pass to the composer
            composer.addPass(outlinePass);
            scene.userData.outlineEnabled = true;
            return outlinePass;
        }

        // A function that creates a storm in the scene
        function createStormScene(camera, terrain, terrainSize) {
            // Sets the user data for the lightning 
            scene.background = new THREE.Color(0x050505);
            scene.userData.canGoBackwardsInTime = false;
            scene.userData.camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 20, 10000);
            scene.userData.camera.position.set(0, 0.2, 1.6).multiplyScalar(GROUND_SIZE * 0.5);
            scene.userData.lightningColor = new THREE.Color(0xB0FFFF);
            scene.userData.outlineColor = new THREE.Color(0x00FFFF);
            scene.userData.lightningMaterial = new THREE.MeshBasicMaterial({ color: scene.userData.lightningColor });
            // Creates some ray parameters to direct the lightning
            const rayDirection = new THREE.Vector3(0, - 1, 0);
            let rayLength = 0;
            const vec1 = new THREE.Vector3();
            const vec2 = new THREE.Vector3();

            // Set up the parameters for the storm such as speed, frequency, and recursion rate
            scene.userData.rayParams = {
                radius0: 1,
                radius1: 0.5,
                minRadius: 0.3,
                maxIterations: 7,

                timeScale: 1,
                propagationTimeFactor: .01,
                vanishingTimeFactor: .7,
                subrayPeriod: .1,
                subrayDutyCycle: .7,
                deathTime: 1,

                maxSubrayRecursion: 3,
                ramification: 3,
                recursionProbability: 0.4,

                roughness: 0.85,
                straightness: 0.65,

                // when a subarray is created... idk man
                onSubrayCreation: function (segment, parentSubray, childSubray, lightningStrike) {

                    lightningStrike.subrayConePosition(segment, parentSubray, childSubray, 0.6, 0.6, 0.5);
                    rayLength = lightningStrike.rayParameters.sourceOffset.y;
                    vec1.subVectors(childSubray.pos1, lightningStrike.rayParameters.sourceOffset);
                    const proj = rayDirection.dot(vec1);
                    vec2.copy(rayDirection).multiplyScalar(proj);
                    vec1.sub(vec2);
                    const scale = proj / rayLength > 0.5 ? rayLength / proj : 1;
                    vec2.multiplyScalar(scale);
                    vec1.add(vec2);
                    childSubray.pos1.addVectors(vec1, lightningStrike.rayParameters.sourceOffset);
                }
            };

            // Make a new lightning storm with the given parameters
            storm = new LightningStorm({
                size: GROUND_SIZE,
                minHeight: 400,//Determine how low the lightning can generate at
                maxHeight: 800,
                maxSlope: 0.6,
                maxLightnings: 1,
                lightningMinPeriod: 20,
                lightningMaxPeriod: 30,
                lightningParameters: scene.userData.rayParams,
                lightningMaterial: scene.userData.lightningMaterial,
            });

            //Add the storm to the scene, add the renderpass to the composer, and cal createoutline
            scene.add(storm);
            composer.passes = [];
            composer.addPass(new RenderPass(scene, scene.userData.camera));
            createOutline(scene, storm.lightningsMeshes, scene.userData.outlineColor);

            // render the scene with the outline
            scene.userData.render = function (time) {
                storm.update(time);
                if (scene.userData.outlineEnabled) {
                    composer.render();
                } else {
                    renderer.render(scene, scene.userData.camera);
                }
            };
        }



        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that creates a tree
        function TreeBuilder(string, params, texture) {
            // The characteristics of the tree
            this.string = string;
            this.params = params;
            this.texture = texture;

            //Function that builds the tree
            this.build = function () {
                //Init params for the tree
                let state = {
                    bRadius: this.params.branchRadius,
                    bLength: this.params.branchLength,
                    bReduction: this.params.branchReduction,
                    bMinRadius: this.params.branchMinRadius,
                    position: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Quaternion()
                }
                // The stack used to keep track of where elements go 
                let stateStack = [];

                //Set the materials properites for the branches and leaves
                let tree = new THREE.Object3D();
                let branchMaterial = this.texture;


                // Create a random number to determine if the tree has leaves or not and what 
                //shape leaf it will be
                let random = Math.random();

                // For the length of the grammar string
                for (let i = 0; i < this.string.length; i++) {
                    // Get the character and create a random number
                    let char = this.string.charAt(i);

                    let rand = Math.random();
                    // If the character is F, build 0, 1, or 2 branches depending on rand
                    if (char == "F") {
                        if (rand < .75) {
                            tree.add(buildBranch(state, branchMaterial));
                        }
                        else if (rand > .95) {
                            tree.add(buildBranch(state, branchMaterial));
                            tree.add(buildBranch(state, branchMaterial));
                        }
                    }

                    //Reassign rand
                    rand = Math.random();
                    // For the z axis
                    // If the character is +, rotate the branch 180 or -180 degrees depending on rand
                    if (char == "+") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -this.params.delta * Math.PI / 180));
                        }
                    }

                    // Reassign rand
                    rand = Math.random();
                    // For the y axis
                    // If the character is >, rotate the branch 180 or -180 degrees depending on rand
                    if (char == ">") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.params.delta * Math.PI / 180));
                        }
                    }
                    // Reassing rand
                    rand = Math.random();
                    // For the x axis
                    // If the character is <, rotate the branch 180 or -180 degrees depending on rand
                    if (char == "<") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.params.delta * Math.PI / 180));
                        }
                    }
                    // If the characters are [ or ], pop or push a clone of the state respectively 
                    if (char == "[") {
                        stateStack.push(cloneState(state));
                        state.bRadius = (state.bRadius - state.bReduction) > state.bMinRadius ? (state.bRadius - state.bReduction) : state.bRadius;
                    }
                    if (char == "]") {
                        state = cloneState(stateStack.pop());
                    }

                }
                // Turn on shadows for the tree
                tree.castShadow = true;
                // Return the tree
                return tree;
            }
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that builds a branch 
        function buildBranch(state, material) {
            // Set the rotation to state rotation
            var transform = new THREE.Quaternion();
            transform.multiply(state.rotation);

            // Set the position to be appropriate for the tree
            var position = new THREE.Vector3(0.0, state.bLength / 2, 0.0);
            // Apply the rotation of the state
            position.applyQuaternion(state.rotation);
            // Add the branch position to the tree position
            state.position.add(position);

            // Create the branch geometry and mesh
            var geometry = new THREE.CylinderBufferGeometry(state.bRadius, state.bRadius, state.bLength, 16);
            var branch = new THREE.Mesh(geometry, material);
            // Copy the rotation and position of the state
            branch.quaternion.copy(state.rotation);
            branch.position.copy(state.position);

            // Add the position to the state
            state.position.add(position);
            //Turn on shadows for the branch
            branch.castShadow = true;
            //Return the branch
            return branch;

        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that clones the current state
        function cloneState(state) {
            // Return the clone
            return {
                bRadius: state.bRadius,
                bLength: state.bLength,
                bReduction: state.bReduction,
                bMinRadius: state.bMinRadius,
                position: new THREE.Vector3().copy(state.position),
                rotation: new THREE.Quaternion().copy(state.rotation)
            }
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that creates parameters for a tree
        function Params(axiom, iterations, delta, branchLength,
            branchRadius, branchReduction, branchMinRadius) {
            this.axiom = axiom ? axiom : "F";
            this.iterations = iterations ? iterations : 4;
            this.delta = delta ? delta : 25;
            this.branchLength = branchLength ? branchLength : 3;
            this.branchRadius = branchRadius ? branchRadius : 0.4;
            this.branchReduction = branchReduction ? branchReduction : 0.1;
            this.branchMinRadius = branchMinRadius ? branchMinRadius : 0.1;
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that reads through the rules and reformats them for use
        function parseRules(rules) {
            var result = {};
            // Split on the new line
            rules.split("\n").forEach(function (a) {
                // For each line, split at the = sign
                var line = a.split("=");
                // If the result is not the first thing in line
                if (!result[line[0]]) {
                    // Empty out result at that index
                    result[line[0]] = [];
                }
                // Push the line to result
                result[line[0]].push(line[1])
            });
            // Return the result
            return result;
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that rewrites the rules
        function Rewriter(rules) {

            this.rules = rules;

            this.rewrite = function (params) {
                // Get the axiom of the params
                let result = params.axiom;
                // For each param
                for (let i = 0; i < params.iterations; i++) {
                    let localResult = "";
                    // For each axiom
                    for (let j = 0; j < result.length; j++) {
                        // Get that character and set it to the rule of that character
                        let char = result.charAt(j);
                        let rule = this.rules[char];
                        // If the rule is undefined, add the result of getrule 
                        if (rule !== undefined) {
                            localResult += getRule(rule);
                            // Else add the character
                        } else {
                            localResult += char;
                        }
                    }
                    // Set result to localresult
                    result = localResult;
                }
                //Return result
                return result;
            };
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that chooses which portion of the rule to use based on probability
        function getRule(rules) {
            var probability = rules.length;
            var choice = probability > 1 ?
                parseInt((((Math.random() * probability) + 1) * 1000) / 1000) - 1 : 0;

            // Return which rule to use
            return rules[choice];
        }

        //https://codepen.io/Xanmia/pen/nqyMgJ
        //This link helped us identify how to create particle explosions in our code
        //This function actually creates the particles that will explode whenever the camera collides with an object
        function ExplodeAnimation(x, y, z) {
            var geometry = new THREE.Geometry(); //Create a geometry

            for (let i = 0; i < totalObjects; i++) { //Iterates a set number of times. Creates another particle each time
                var vertex = new THREE.Vector3(x, y, z); //Creates a new vector 3 with the given x y z values
                geometry.vertices.push(vertex);//Adds the vector as vertices to the geomety
                //Creates different directions the particles will explode off into based on the particles position
                dirs.push({ x: (Math.random() * movementSpeeds) - (movementSpeeds / 2), y: (Math.random() * movementSpeeds) - (movementSpeeds / 2), z: (Math.random() * movementSpeeds) - (movementSpeeds / 2) });
            }

            var colorsRand = Math.round(Math.random() * 17) //Generates a random number that will be used to randomly
            //select a color from the color array
            var material = new THREE.PointsMaterial({ size: objectSize, color: 0xFFFF00 }); //Create point material
            //with random color
            this.object = new THREE.Points(geometry, material);; //make a mesh as the object of this function
            scene.add(this.object); //Adds the particle object to the scene

            this.update = function () { //Function which adds all of these particles to the scene and sends them off in random
                //directions
                var pCount = totalObjects; //Set pcount equal to the number of total particles we want
                while (pCount--) { //decrement pcount
                    var particle = this.object.geometry.vertices[pCount] //Creates a particle using the vertices of the object
                    //Continuously increments the x,y,z position of the particle
                    particle.y += dirs[pCount].y;
                    particle.x += dirs[pCount].x;
                    particle.z += dirs[pCount].z;
                }
                this.object.geometry.verticesNeedUpdate = true;
            }
        }



        // a function that initializes the parameters for the game
        function initParameters(level) {
            // Each level determines the headstart the user gets, the stamina of the user, and
            // the speed and acceleration of the monster. 
            // and the stamina for the player
            if (level == "easy") {
                console.log("easy");
                distance = 60; //60
                monsterSpeed = .06;//.06
                stamina = 100;
                increment = 2;
            }
            else if (level == "medium") {
                console.log("medium");
                distance = 50;
                monsterSpeed = .06;
                stamina = 100;
                increment = 2;
            }
            else if (level == "hard") {
                console.log("hard");
                distance = 60;
                monsterSpeed = .05;
                stamina = 70;
                increment = 1;
            }
        }

        // initializes the star icon in the top right of the HUD scene
        function initStarIcon(color, scale) {
            // create the star icon group and the geometry, material, and mesh for the center of it
            let starGroup = new THREE.Group();
            var geometry = new THREE.CircleGeometry(25, 5)
            var material = new THREE.MeshBasicMaterial({
                color: color, side: THREE.DoubleSide
            })
            var circle = new THREE.Mesh(geometry, material)
            starGroup.add(circle);

            // store the vertices of the center (a pentagon)
            // these are used to create 2 points of each arm of the star
            let known = circle.geometry.vertices;
            // these vector3 represent the point sof each arm of the star
            let additionalPoints = [
                (new THREE.Vector3(44, 32, 0)),
                (new THREE.Vector3(-15, 52, 0)),
                (new THREE.Vector3(-52, 2, 0)),
                (new THREE.Vector3(-15, -52, 0)),
                (new THREE.Vector3(44, -30, 0))
            ];
            // for the length of the known points
            for (let i = 1; i < known.length; i++) {
                // create a new shape
                const shape = new THREE.Shape();
                // if the index is less than 5 (if it is not the last arm of the star)
                if (i < 5) {
                    // create the triangle for that arm
                    shape.moveTo(known[i].x, known[i].y);
                    shape.lineTo(known[i + 1].x, known[i + 1].y);
                    shape.lineTo(additionalPoints[i - 1].x, additionalPoints[i - 1].y);
                }
                // for the last arm of the star it is modified because you need to loop
                // around to the first value in the array
                else {
                    shape.moveTo(known[i].x, known[i].y);
                    shape.lineTo(known[1].x, known[1].y);
                    shape.lineTo(additionalPoints[i - 1].x, additionalPoints[i - 1].y);
                }
                // create the geometry, material, and mesh for the arms
                const tgeometry = new THREE.ShapeGeometry(shape);
                const tmaterial = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
                const tmesh = new THREE.Mesh(tgeometry, tmaterial);
                starGroup.add(tmesh);
            }
            // set the rotation in order to make the star upright
            // scale and position the stargroup to fit in the top right of the screen
            starGroup.rotation.z = .94;
            starGroup.scale.set(scale, scale);
            starGroup.position.set(windowWidth - (windowWidth * .60), windowHeight - (windowHeight * .65), 0);
            return starGroup;
        }

        // a function to initialize the heart icons
        //Src: https://threejs.org/docs/#api/en/extras/core/Shape
        function initHeartIcon(x) {
            // keep the y consistent for each heart icon but use preset x values to space them out
            // in the bottom left corner
            const y = windowHeight - (windowHeight * .8);
            const heartShape = new THREE.Shape();

            // create the vertices and curves to form the heart shape
            heartShape.moveTo(x + 5, y + 5);
            heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
            heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
            heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19);
            heartShape.bezierCurveTo(x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7);
            heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
            heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

            // create the geometry, mesh, and material for the heart
            const geometry = new THREE.ShapeGeometry(heartShape);
            const hmaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, hmaterial);

            // set the rotation and scale then turn on mesh layers
            mesh.rotation.z = -3.15;
            mesh.scale.set(2, 2);
            mesh.layers.enable(1);
            // add it to the hud scene and heart array
            sceneHUD.add(mesh);
            heartArray.push(mesh);
        }


        // //Initializes Cursor
        // function initCursor() {
        //     cursorGeom = new THREE.SphereGeometry(0.02, 16, 16); //Creates a cursor geom
        //     cursorMat = new THREE.MeshBasicMaterial({ transparent: true }); //Cursor material with color
        //     cursorMat.opacity = 0;
        //     cursor = new THREE.Mesh(cursorGeom, cursorMat); //Creates mesh
        //     scene.add(cursor); //Adds cursor to the scene
        //     spheres.push(cursor); //Adds cursor to the spheres array
        // }

        //Initializes the sphere surrounding our "world"
        function initWorld() {
            worldGeom = new THREE.SphereGeometry(550, 32, 32); //Creates world Geometry (is a sphere)
            worldMat = new THREE.MeshBasicMaterial({
                color: 0xADD8E6,
                side: THREE.DoubleSide, //Gives the sphere two sides so it is visible from inside and outside
                map: loader.load("skies/cloud3.jpg")
            }); //Textures the sphere with clouds

            worldMat.transparent = true; //Makes the world material halfway transparent in order to make the sky look
            //more realistic
            worldMat.opacity = .5;
            world = new THREE.Mesh(worldGeom, worldMat); //Creates world mesh
            world.rotateZ(1.4708); //Rotates world specific amount to avoid the ""
            scene.add(world);
            worldItems.push(world);

        }

        // a function that creates the flashlight
        function initFlashLight() {
            //create the pointlight and set the shadow parameters
            let light = new THREE.PointLight(0xffff00, 6, 350, 8);
            light.castShadow = true;
            light.shadow.bias = .0005;
            light.shadow.radius = 100;
            light.shadow.mapSize.width = 2048;
            light.shadow.mapSize.height = 2048;

            // position the flashlight next to the side of the player and set the light boolean to on
            light.position.set(camera.position.x, camera.position.y, camera.position.z + 10);
            scene.add(light);
            spotLightOn = true;
            return (light);
        }

        //Creates the sun/moon and their corresponding point lights
        function initLights(hexCode, x, y, z, intensity) {
            renderer.setClearColor(0x000608);//Changes the color of the world to teh 
            //Creates a sphere (sun/moon) and corresponding pointlight and adds them both to the scene

            this.bulbGeometry = new THREE.SphereGeometry(10, 32, 16); //Creates sphere geometry
            this.bulbLight = new THREE.PointLight(hexCode, intensity, 20000); //Creates point light

            this.bulbMat = new THREE.MeshBasicMaterial({ //Creates bulb material for the light and customizes it
                //emissive: 0x880808,
                //emissiveIntensity: 1,
                color: 0x880808
            });

            this.bulbLight.add(new THREE.Mesh(this.bulbGeometry, this.bulbMat)); //Adds bulb geometry & bulb light to the point light
            this.bulbLight.position.set(x, y, z); //Positions the light 
            this.bulbLight.castShadow = true; //Casts shadow from the light
            this.bulbLight.shadow.bias = - 0.0005; // Reduces self-shadowing on double-sided objects
            this.bulbLight.shadow.radius = 8; //Increases smoothness of the shadows
            this.bulbLight.shadow.mapSize.width = 2048; //Increases resolution of shadows
            this.bulbLight.shadow.mapSize.height = 2048;
            scene.add(this.bulbLight); //Adds point light to the scene
        }


        // the material used for all the starshards (shiny)
        const starMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffff00,
            metalness: .75,
            roughness: 0
        });

        // initialized the star shards
        function initStarShards(numStars) {
            for (let i = 0; i < numStars; i++) {
                // make a new random position
                let position = randomizePositions(380, 5); //380
                // create the geometry, material, and mesh
                const geometry = new THREE.ConeGeometry(10, 30, 3);
                const material = starMaterial;
                const sphere = new THREE.Mesh(geometry, material);
                // turn on shadows anhd position the shard, add it to the starshards array
                sphere.castShadows = true;
                sphere.position.set(position.x, position.y, position.z);
                starShards.push(sphere);
                //worldItems.push(sphere);
                scene.add(sphere);
            }
        }

        // A function that makes the trees for the scene. There are 3 types of wood and 3 grammars
        function initTrees(start, end) {
            //Iterates for 30 times
            for (let i = start; i < end; i++) {
                let params;
                let rules;
                if (i < 10) {
                    params = new Params("F", 2, 22.5, 25, Math.round(Math.random() * 2));
                    rules = parseRules("F=F[+F]F[F>>][<F]\nF=F[+F]F[+<<F][F>]");
                }
                else if (i <= 20) {
                
                    params = new Params("F", 3, 15, 15, Math.round(Math.random() * 2));
                    rules = parseRules("F=F>[<+F]F[+F>]<F\nF=F>[+F^>^]F\nF=F[+F>]F>");
                }
             
                let rewriter = new Rewriter(rules); //Choose which rule to use based on some probability out of the rules 
                //written in the string
                let string = rewriter.rewrite(params); //Returns which rules were selected
                let positionTree = randomizePositions(380, 5); //Randomizes position of the tree
                let newTree = new TreeBuilder(string, params, wood).build(); //Builds tree with rules, params, and specific texture
                newTree.position.set(positionTree.x, positionTree.y, positionTree.z);//Sets position of tree

                //Enables shadows for tree
                newTree.castShadow = true;
                newTree.receiveShadow = true;
                //Pushes tree created onto the worldItems array and trees array
                //worldItems.push(newTree);
                trees.push(newTree);

                scene.add(newTree);
            }
        }

        //Function to make the body of the body that casts a shadow
        function initBody() {

            //Creates material that will be used for each body part
            let wholeBodyMaterial = new THREE.MeshPhongMaterial({
                colorWrite: false, //Makes the material invisible
                depthWrite: false
            });

            //Creates head mesh, positions it, and adds it to the group for the body
            let headGeometry = new THREE.SphereGeometry(4, 32, 32);
            let headMaterial = wholeBodyMaterial;
            let head = new THREE.Mesh(headGeometry, wholeBodyMaterial);
            head.castShadow = true;
            head.receiveShadow = true;
            humanGroup.add(head);
            head.position.set(0, 2, 0);

            //Creates body mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let bodyGeometry = new THREE.BoxGeometry(3, 8, 3)
            let bodyMaterial = wholeBodyMaterial;
            let body = new THREE.Mesh(bodyGeometry, wholeBodyMaterial)
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.set(0, -4, 0);
            humanGroup.add(body)

            //Creates the left arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let leftArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            let leftArmMaterial = wholeBodyMaterial;
            let leftArm = new THREE.Mesh(leftArmGeometry, wholeBodyMaterial)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.rotateZ(-Math.PI / 3);
            leftArm.position.set(-3.3, -3.5, 0);
            humanGroup.add(leftArm);

            //Creates the right arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let rightArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            let rightArmMaterial = wholeBodyMaterial;
            let rightArm = new THREE.Mesh(rightArmGeometry, wholeBodyMaterial)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.rotateZ(Math.PI / 3);
            rightArm.position.set(3.3, -3.5, 0);
            humanGroup.add(rightArm);

            //Creates the right leg mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let rightLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            let rightLegMaterial = wholeBodyMaterial;
            let rightLeg = new THREE.Mesh(rightLegGeometry, wholeBodyMaterial)
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            rightLeg.rotateZ(Math.PI / 6);
            rightLeg.position.set(3.3, -12, 0);
            humanGroup.add(rightLeg);

            //Creates the left arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let leftLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            let leftLegMaterial = wholeBodyMaterial;
            let leftLeg = new THREE.Mesh(leftLegGeometry, wholeBodyMaterial)
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            leftLeg.rotateZ(-Math.PI / 6);
            leftLeg.position.set(-3.3, -12, 0);
            humanGroup.add(leftLeg);

            scene.add(humanGroup);

        }


        // a function to initialize the fog for the scene
        function initFog() {
            const near = 30;
            const far = 100;
            const color = 0xff0000;
            scene.fog = new THREE.FogExp2(color, 0); //.005
        }

        //Creates terrain and water that will appear in the scene
        function initTerrain() {

            waterGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256); //Creates water geom
            waterMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, //Sets color to white
                map: loader.load('water/water.jpg'), //Loads in water texture
                side: THREE.DoubleSide//Makes doublesided
            });

            waterMat.opacity = .7; //Makes the opacity to 70%
            waterMat.transparent = true;
            water = new THREE.Mesh(waterGeom, waterMat);//Creates water mesh

            water.rotation.x = -Math.PI / 2; //Rotates water so that it appears on the ground surface
            water.position.y = -25;//Positions the water so that only some water will appear to the user depending on
            //how hilly a certain part is
            water.receiveShadow = true; //Water can receive shadows
            scene.add(water); //Adds water to scene
            // worldItems.push(water); //Adds water to worldItems so that the cursor will recognize the water and not disappear

            terrainGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256); //Creates terrain geometry
            terrainMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a2e18,
                map: loader.load('land/sand3.jpg'), //Loads in terrain texture
                side: THREE.DoubleSide
            }); //Makes terrain doublesided
            terrain = new THREE.Mesh(terrainGeom, terrainMat); //Creates terrain mesh
            terrain.rotation.x = -Math.PI / 2;//Rotates terrain so that it appears on the ground surface

            scene.add(terrain);

            //Makes shadows not completely opaque on the terrain.
            terrainShadowMat = new THREE.ShadowMaterial(); //Creates shadow material
            terrainShadowMat.opacity = 0.5; //The terrain shadow is 50% opaque which allows individuals to see the terrain
            //underneath
            terrainShadow = new THREE.Mesh(terrainGeom, terrainShadowMat); //Creates shadow mesh
            terrainShadow.receiveShadow = true;//Shadow mesh receives the shadow
            terrainShadow.castShadow = true;//Shadow mesh casts shadow
            terrainShadow.position.copy(terrain.position);//Copies terrains position
            terrainShadow.rotation.copy(terrain.rotation);//Copies terrains rotation
            scene.add(terrainShadow);


            //src: http://www.stephanbaker.com/post/perlinterrain/
            var vertices = terrain.geometry.attributes.position.array;
            for (var i = 0; i <= vertices.length; i += 3) {
                vertices[i + 2] = peak * perlin.noise(
                    vertices[i] / smoothing,
                    vertices[i + 1] / smoothing
                );
            }
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();


            terrain.castShadow = true;
            //worldItems.push(terrain);
        }

        //Creates sun and moon bulblights
        function initMoon() {
            moon = new initLights(0xdde2e5, 0, 280, 0, .1);
            renderer.setClearColor(0x094f6d);
            world.material.color.setHex(0x094f6d);
            //worldItems.push(moon.bulbLight);
        }


        //Function that randomizes a position (x,y,z) coordinate in the terrain
        function randomizePositions(limit, bounds) {
            let rayHeight = new THREE.Raycaster();
            let rayDirection = new THREE.Vector3(0, -1, 0);//Gives direction for raycaster
            //Below recalculates the world matrix of the objects and their descendants on the current frame
            terrain.updateMatrixWorld(true);
            scene.updateMatrixWorld(true);
            let treePos = new THREE.Vector3();
            //Gives x and z a random position within the bounds of the terrain
            //let xPos = Math.random() * (limit - bounds) + bounds;
            //let zPos = Math.random() * (limit - bounds) + bounds;

            let xPos = newRandom(bounds, (limit - bounds));
            let zPos = newRandom(bounds, (limit - bounds));

            let yPos = 100;//Gives the y pos a set point above the terrain

            //Randomizes whether the x and z position were negative
            // if (random() == true) {
            //     xPos *= -1;
            // }
            // if (random() == true) {
            //     zPos *= -1;
            // }

            treePos.set(xPos, yPos, zPos);//Sets treePosition to the randomized x,y and z coordinates
            rayHeight.ray.set(treePos, rayDirection.normalize()); //Has ray cast downwards from the treePos
            let intersectHeight = rayHeight.intersectObject(terrainShadow); //Finds where the ray intersects with the 
            //terrain
            if (intersectHeight.length != 0) {
                yPos = intersectHeight[0].point.y; //Sets the yPos to where the ray intersected with the terrain
            }
            treePos.set(xPos, yPos, zPos);//Sets treePosition to the randomized x,y and z coordinates
            return treePos;
        }


        // initialize the smoke for the monster 
        function initMonster() {
            // load the smoke texture
            smokeTexture = loader.load('monster/smoke1.png');
            // create the material, geometry, and mesh
            smokeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, map: smokeTexture, transparent: true, side: THREE.DoubleSide });
            smokeGeo = new THREE.DodecahedronGeometry(30, 0);

            // load the texture for the eyes
            let eyesTexture = loader.load('monster/eyes.png');
            // create the geometry, material, and mesh for the eyes
            let eyesGeom = new THREE.PlaneGeometry(40, 40);
            let eyesMat = new THREE.MeshBasicMaterial({ transparent: true, map: eyesTexture, side: THREE.DoubleSide });
            let eyes = new THREE.Mesh(eyesGeom, eyesMat);
            // position the eyes and add them to the monster group
            eyes.position.set(0, 70, 30);
            monsterGroup.add(eyes);

            // load the texture for the smile
            let smileTexture = loader.load('monster/smile.png');
            // create the geometry, material, and mesh for the smile
            let smileGeo = new THREE.PlaneGeometry(40, 40);
            let smileMat = new THREE.MeshBasicMaterial({ transparent: true, map: smileTexture, side: THREE.DoubleSide });
            let smile = new THREE.Mesh(smileGeo, smileMat);
            // position the mouth and add it to the monster group
            smile.position.set(0, 35, 30);
            monsterGroup.add(smile);

            // create an array to store the smoke particles 
            //src: https://en.threejs-university.com/2021/08/04/creating-a-smoke-effect-in-three-js/
            smokeParticles = [];
            // make 40 particles for the monster
            for (let p = 0; p < 40; p++) {
                // create a random number within the given bounds
                x = newRandom(0, 40);
                y = newRandom(0, 50);
                y = y + 50

                // make a new mesh for that particle and randomize the rotation
                var particle = new THREE.Mesh(smokeGeo, smokeMaterial);
                let rotation = newRandom(0, 1000);

                // set the position of the particle and rotate it to the former rotation
                particle.position.set(x, y, 0);
                particle.rotation.z = rotation;
                // add it to the scene, the smokeparticles array, and the monster group
                scene.add(particle);
                smokeParticles.push(particle);
                monsterGroup.add(particle);
            }

            // add the monstergroup to the scene and position the monster at the
            // first footstep 
            scene.add(monsterGroup);
            monsterGroup.position.set(previousPos[0].x, previousPos[0].y, previousPos[0].z);
        }


        // a function that roates the smoke particles in the monster
        function evolveSmoke() {
            // get the length of the particles array
            var sp = smokeParticles.length;
            while (sp--) {
                // rotate the particle in the z axis by delta times 10
                smokeParticles[sp].rotation.z += (delta * 10);
            }
        }

        // a function that executes all the logic for the campfire
        function campFireLogic() {
            // if the user is within 100 units of the cmapfire and the campfire is not out:
            if (calcPointDistance(camera.position, campfire.position) < 100 && campfire.height > 0) {
                // set the campfire fade value to true
                campfire.fade = true;
                console.log("fading");
            }
            // otherwise if the player is out of range
            else {
                // set the campfire fade value to false
                campfire.fade = false;
                console.log("steady flame");
            }
            // for each particle in the campfire
            for (let p = 0; p < campfire.particles.length; p++) {
                // store the campfire particle for ease of use later
                let cfp = campfire.particles[p];
                // translate the particle on the y axis using the particles unique direction
                cfp.mesh.translateY(campfire.particles[p].direction.y);
                // translate the particles on the x and z axis according to the wind value and their mass
                cfp.mesh.translateX(wind / cfp.size);
                cfp.mesh.translateZ(wind / cfp.size);
                // if the particle is over the height limit assigned to the fire, modified by the particle size
                // and the assigned fade rate (prevents large particles from going all the way to the top)
                // OR the particle strays too far in the x or z direction
                if (cfp.mesh.position.y > campfire.position.y + campfire.height - cfp.size * verticalFade
                    || cfp.mesh.position.x > campfire.position.x + 10
                    || cfp.mesh.position.x < campfire.position.x - 10
                    || cfp.mesh.position.z > campfire.position.z + 10
                    || cfp.mesh.position.z < campfire.position.z - 10
                ) {
                    // set the particle back to its starting position
                    cfp.mesh.position.set(cfp.position.x, cfp.position.y, cfp.position.z);
                }
            }
            // if the campfire height is over 0 and the fade is on
            if (campfire.height > 0 && campfire.fade == true) {
                // reduce the height of the campfire by the overall fade value
                campfire.height -= overallFade;
            }
            // if the campfire height is less than or equal to 0
            if (campfire.height <= 0) {
                // for each particle
                for (let p = 0; p < campfire.particles.length; p++) {
                    // change the particle color to black to represent coals
                    campfire.particles[p].mesh.material.color.setHex(0x000000);

                }
                // set the fade to false and turn out the campfire light
                campfire.fade = false;
                console.log("fire out");
                campfire.light.intensity = 0;
            }

        }


        // a function that changes the wind as the program runs
        function windLogic() {
            // if the wind timer is over 3
            if (windTimer > 3) {
                // create a new direction for the wind and reset the wind timer
                console.log("wind changes");
                wind = newRandom(0, .5);
                windTimer = 0;
            }

        }

        // plays thunder and rain sounds throughout the game
        function thunderAndRain() {
            // if the thunder timer is greater than the max thunder interval
            if (timerThunder >= maxThunder) {
                // play a random audio from the thunder array
                //console.log("thunder playing");
                let index = Math.floor(Math.random() * 4);
                play(thunderNoises[index]);
                // reset the thunder timer and randomize the new max thunder value
                timerThunder = 0;
                maxThunder = Math.random() * 5 + 2;
            }
            // if the rain timer is greater than 4
            if (rain >= 4) {
                // play the main rain and thunder audio and reset the rain timer
                play(thunderNoises[1]);
                rain = 0;
            }
        }

        // a function that sets the stamina bar and fog
        function staminaLogic() {
            // if the stamina is greater than 50% of the max stamina
            if (stamina > maxStamina * .5) {
                // make the stamina bar green
                staminaBar.material.color.set(0x5CFF5C);
            }
            // if the stamina is less than 20% of the max stamina
            else if (stamina < maxStamina * .2) {
                // make the stamina bar red
                staminaBar.material.color.set(0xDF362D);
            }
            // otherwise (the middle 30%)
            else {
                // make the stamina bar yellow
                staminaBar.material.color.set(0xFFC55C);
            }
            // scale the rate at which the stamina bar shrinks and grows based on the stamina
            scales = 2.015 * (stamina - 5) * .01;
            // if the player is moving and the stamina is over 0
            if (moving == true && stamina > 0) {
                // if the stamina is over 10% of the max stamina
                if (stamina > maxStamina * .1) {
                    // scale the stamina bar by scales
                    staminaBar.scale.x = scales;
                }
                // decrease stmaina by the fitness value (how quickly the stamina bar shrinks)
                stamina -= fitness;
                // if the game is still ongoing
                if (gameState == 0) {
                    // increase the fog in the game
                    scene.fog.density += .00003;
                }
            }
            // otherwise if the player is not moving and the stamina is less that the max stamina and the 
            // stamina is over 0
            else if (moving == false && stamina < maxStamina && stamina >= 0) {
                // scale the stamina bay by the scale and increase the stamina by the fitness times 5
                // (done to make recovery faster than losing stamina)
                staminaBar.scale.x = scales;
                stamina += fitness * 5;
                // if the game is still ongoing
                if (gameState == 0) {
                    // decrease the fog in the game
                    scene.fog.density -= .00003 * 5;
                }
            }
        }


        // a function that handles the star shards after you collect them
        function movingStarShardLogic() {
            // if there is something in the starshards array
            if (movingStarShard.length != 0) {
                // for each shard
                for (let i = 0; i < movingStarShard.length; i++) {
                    // if the shard y position is less than 450
                    if (movingStarShard[i].position.y <= 450) {
                        // move the shard up 
                        movingStarShard[i].translateY(5);
                    }
                    // otherwise (if it is over 450 y)
                    else {
                        // call addstars to update the star icon 
                        addStars();
                        // create an explostion at the position of the starshard
                        parts.push(new ExplodeAnimation(movingStarShard[i].position.x, movingStarShard[i].position.y, movingStarShard[i].position.z));
                        // remove and dispose of the shard from the scene
                        scene.remove(movingStarShard[i]);
                        movingStarShard[i].material.dispose();
                        movingStarShard[i].geometry.dispose();
                        // remove the shard from the array
                        movingStarShard.splice(i, 1);
                    }
                }
            }
        }

        // a function that handles the positioning for the camera during movement
        function cameraPositioning() {
            // raycast from the camera position
            let ray = new THREE.Raycaster();
            var rayPos = new THREE.Vector3();
            rayPos.set(camera.position.x, camera.position.y, camera.position.z);
            var rayDir = new THREE.Vector3(0, -1, 0);
            ray.set(rayPos, rayDir);
            // keeps track of where the ray intersects the terrain
            let intersect = ray.intersectObject(terrain);
            // if the raycaster is intersecting the terrain
            if (intersect.length != 0) {
                // place the camera 20 units above the ground
                camera.position.y = (intersect[0].point.y + 20)
            }
            // in an edge case where the camera cannot find the terrain during loading, set the camera height to 50
            // this ensures that the camera is above the max height for the terrain
            else {
                camera.position.y = 50;
            }
        }

        // a function that handles the logic for the stars in the sky
        function skyStars() {
            // if the sky stars array is not empty
            if (prettyStars.length != 0) {
                // Randomly choose whether each star from the prettystar array has their color changed
                //src: https://kellylougheed.medium.com/3d-starry-night-with-three-js-7f9191bbcb84
                for (let i = 0; i < prettyStars.length; i++) {
                    lightness > 80 ? lightness = 50 : lightness++;
                    if (Math.random() > .5) {
                        prettyStars[i].material.color = new THREE.Color("hsl(255, 100%, " + lightness + "%)");
                    }
                }
            }

            // for each star in the shooting star array
            for (let i = 0; i < shootingStars.length; i++) {
                // move the star in the direction at the same index in the star directions array
                shootingStars[i].translateX(starXDirs[i]);
                shootingStars[i].translateZ(starZDirs[i]);
            }
        }

        // a function that resets the monster and game values when the player is caught
        function caughtReset() {
            // for each level, reset the distance and the monsterspeed
            if (level == 'hard') {
                distance = 50;
                monsterSpeed = .03;
            }
            else if (level == 'medium') {
                distance = 50;
                monsterSpeed = .06;
            }
            else {
                distance = 60;
                monsterSpeed = .06;
            }
            // clear the previous position array and reduce the headstart to 80% of its original value
            previousPos = [];
            distance = distance * .8;
            // push the camera position the the previous pos array
            previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z));
        }

        //A function which describes monster movement while the game is in play
        function monsterLogic() {
            //If the user has moved a specific number of steps away from the spawning point and if the user is not
            //currently hiding at a campfire, the moster can move
            if (previousPos.length > distance && campfire.fade == false) {
                if (spawningIn == true) { //If the monster has not spawned in yet, spawn in the monster and play the music
                    play("sounds/close/spawn.mp3");
                    spawningIn = false;
                }
                timer += delta;
                if (timer > monsterSpeed && inJumpscare == false) { //If the user is not currently in a jumpscare then move
                    //the monster at a specified timer speed
                    timer = 0;
                    monsterGroup.position.set(previousPos[0].x, previousPos[0].y, previousPos[0].z); //Set position of the monster
                    //to one of the users previous positions
                    previousPos.shift(); //removes the first element from previous pos array
                    distance -= 1;
                    //If the user is within 15 units from the monster, the user is caught
                    if (calcPointDistance(monsterGroup.position, camera.position) < 15) { ///30
                        console.log("caught");
                        caught = true;
                    }
                     //If the user is within 150 units from the monster, the user is close to being caught and their heartbeat should start pounding
                    else if (calcPointDistance(monsterGroup.position, camera.position) < 150) {
                        heartbeatAudio.play();
                        heartbeatAudio.volume = 1;
                    }
                    //If the user is not within 150 units from the monster then they will not hear their heartbeat
                    else if (calcPointDistance(monsterGroup.position, camera.position) > 150) {
                        heartbeatAudio.pause();
                        heartbeatAudio.currentTime = 0;
                    }
                }
            }
        }

        //Function that creates the losing logic
        function loseLogic() {
            //Increases fog density, makes it appear closer, and turns the color to black
            scene.fog.density = .005;
            scene.fog.near = 10;
            scene.fog.color.set(0x000000);
            gameState = 2;//The game state is now in "lost" mode
            heartbeatAudio.pause(); //Disable the heart beat audio completely
            heartbeatAudio.currentTime = 0;
            gamePaused = true; //The user no longer has control to wander the map
            controls.unlock();
        }

         //Function that creates the winning logic and immediate clean up logic as well
        function winAndCleanup() {
            heartbeatAudio.pause();//Disable the heart beat audio completely
            heartbeatAudio.currentTime = 0;
            jumpscarePositions = []; //Get rid of all jumpscares
            let length = previousPos.length; //DONT KNOW WHAT IMMEDIATE BELOW OES
            if (length > 10) {
                previousPos = previousPos.splice(10, previousPos.length - 10);
            }
            scene.remove(monsterGroup); //Remove monster and dispose all of the group meshes
            monsterGroup.traverse(monsterGroup => monsterGroup.dispose?.());
            scene.remove(storm);//Remove storm
            scene.fog.density = 0; //Get rid of fog
            makeShiba(previousPos); //Make a shiba using one of your previous positions
            shibaCounter += 1;//Increment shiba counter
            let index = Math.floor(Math.random() * 2);
            play(winSounds[index]); //Play random winning noise
        }

        //Function that creates the animation for the end star that appears when a user wins
        function endStarAnimation() {
            let counter = 0;
            if (prettyStars.length > 0) { //If there are still flickering stars in the sky
                for (let i = 0; i < prettyStars.length; i++) {
                    //Using the spring formula, translate the stars to the moon light
                    prettyStars[i].translateX(k * (createRandomPosOrNeg(300, 0) - prettyStars[i].position.x));
                    prettyStars[i].translateY(k * (270 - prettyStars[i].position.y));
                    prettyStars[i].translateZ(k * (createRandomPosOrNeg(300, 0) - prettyStars[i].position.z));
                    prettyStars[i].scale.set(Math.random() * 30 + 10, Math.random() * 30 + 10);
                    //If a flickering star is within a specified distance of the moon, increment the couunter
                    if (calcPointDistance(prettyStars[i].position, moon.bulbLight.position) <= 50) {
                        counter++; 
                    }
                }
            }
            if (counter > prettyStars.length * .95) { //If more than 95 percent of the flickering stars are within distance
                //of the moon then enter this if statement
                moon.bulbLight.intensity = 2; //Increase the moon lights intensity
                //Get rid of moon material and geometry, and change the light color to yellow
                moon.bulbMat.dispose(); 
                moon.bulbGeometry.dispose();
                moon.bulbLight.color.setHex(0xffff00);
                moon.bulbMat.color.setHex(0xffff00);
                if (number == 0) { //If the end star hasnt been added to the scene, add it to the scene and position it 
                    endStar = initStarIcon(0xffff00, .5);
                    endStar.position.set(0, 280, 0);
                    endStar.lookAt(camera.position); //Have it look at the camera
                    scene.add(endStar);
                    number += 1;
                }
                for (let i = 0; i < prettyStars.length; i++) { //Go throughout all of the pretty stars array and dispose of them
                    scene.remove(prettyStars[i]);
                    prettyStars[i].material.dispose();
                    prettyStars[i].geometry.dispose();
                    prettyStars.splice(i, 1);
                }//Change color of the world and its renderer
                renderer.setClearColor(0xffffff);
                world.material.color.setHex(0xffffff);
            }
            else if (counter > prettyStars.length * .9) { //Change the color of the moon to yellow
                moon.bulbLight.color.setHex(0xffffff);
                moon.bulbMat.color.setHex(0xffff00);
            }
        }


        //The animate function is a function which is continuously called for every frame of the program
        function animate() {

            //Increments all timers by delta
            delta = clock.getDelta();
            rain += delta;
            windTimer += delta;
            timerThunder += delta;
            //Calls wind an campfire logic, two animations we constantly want to be playing
            windLogic();
            campFireLogic();
            light.position.set(camera.position.x, camera.position.y, camera.position.z + 10); //Move flashlight
            //to users position no matter what
            monsterGroup.lookAt(camera.position.x, camera.position.y - 30, camera.position.z);//Have monster look at
            //user no matter what
            if (inJumpscare == true) { //If the user is in a jumpscare then have the user constantly looking
                //at the jumpscare
                camera.lookAt(jumpscareLookAt);
            }
            if (gamePaused == false) { //If the game is not paused
                if (gameState != 1) {
                    thunderAndRain(); //Play thunder and rain audio if the user has not yet won
                }
                if (jumpscarePositions.length != 0) {//If there are still jumpscares throughout the map
                    for (let i = 0; i < jumpscarePositions.length; i++) { //Constantly check if the user is close enough to be jumpscared
                        if (calcPointDistance(camera.position, jumpscarePositions[i]) < 30 && calcPointDistance(camera.position, monsterGroup.position) > 15) {
                            let index = Math.floor(Math.random() * 2);
                            jumpscare(index); //Randomize which jumpscare model is called
                            jumpscarePositions.splice(i, 1); //Remove that jumpscare position from 
                        }
                    }
                }
                skyStars();
                if (typeof endStar != 'undefined') { //If the end scene star has been added to the scene, make it's look
                //at the user
                    endStar.lookAt(camera.position);
                }

                staminaLogic();
                evolveSmoke();
                movingStarShardLogic();

                var pCount = parts.length;
                while (pCount--) {
                    parts[pCount].update(); //Keeps exploding the particles
                }

                //Creates a raycaster at the camera position that casts in the -y direction
                cameraPositioning();

                // If the controls are locked in 
                if (controls.isLocked === true) {
                    // Set yPos to the camera position minus 5 then set the group to the camera x z and yPos
                    let yPos = camera.position.y - 5;
                    humanGroup.position.y = (yPos);
                    humanGroup.position.z = (camera.position.z);
                    humanGroup.position.x = (camera.position.x);
                    // Make the group rotation match the camera rotation
                    humanGroup.setRotationFromMatrix(camera.matrix);
                }

                if (gameState == 0) { //If the game is still going
                    //DONT KNOW WHAT BELOW IS DOING
                    if (gameTime > increment) {
                        monsterSpeed -= .01;
                        gameTime = 0;
                    }
                    if (caught == false) {//If the user is not been caught currently
                        if (calcPointDistance(camera.position, previousPos[previousPos.length - 1]) != 0) { //Calculate
                           //if the user has moved from its last position. If they have then add their new position
                           //to the previouspos array
                            previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z))
                        }
                        monsterLogic(); //Call monster movement logic
                    }
                    else if (caught == true) { //If the user was caught
                        if (gameState == 0) { //If the game is still going then decrement the number of lives,
                            //make a heart black, jumpscare the user with the monster, and reset all of the variables afterwards
                            lives -= 1;
                            heartArray[lives].material.color.set(0x000000);
                            jumpscare(-1);
                            caughtReset();
                            caught = false;
                        }
                        if (lives == 0) { //If the user has no more lives then commence losing logic
                            loseLogic();
                        }
                    }
                }
                else if (gameState == 1) { //If the user has won
                    if (shibaCounter == 0) { //If the shiba hasnt been added to the scene yet, add it to the scene and do all winning animatioons
                        winAndCleanup();
                    }
                    if (typeof dog != 'undefined') { //If the shiba exists then make the shiba follow the camera and make it always 
                        //watch the user
                        if (calcPointDistance(camera.position, previousPos[previousPos.length - 1]) != 0) {
                            previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z))
                        }
                        if (previousPos.length > 10) {
                            dog.position.set(previousPos[previousPos.length - 10].x, previousPos[previousPos.length - 10].y, previousPos[previousPos.length - 10].z)
                            previousPos.shift();
                        }
                        dog.lookAt(camera.position);
                    }
                    endStarAnimation();
                }
                hudTexture.needsUpdate = true;
                // Render HUD on top of the scene.
                renderer.render(scene, camera);
                renderer.render(sceneHUD, cameraHUD);
                requestAnimationFrame(animate);
            }
        }

        // a function that is called continuously in animate that handles the cursor, hightlighting, and sun/moon rotation
        function render() {
            currentTime += scene.userData.timeRate * clock.getDelta();
            if (currentTime < 0) {
                currentTime = 0;
            }
            scene.userData.render(currentTime);
            // update the size of the window if needed
            updateSize();
            requestAnimationFrame(render);
            // Rotate the sun and moon around the world 

            hudTexture.needsUpdate = true;
            // Render HUD on top of the scene.
            renderer.render(scene, camera);
            renderer.render(sceneHUD, cameraHUD);
            //renderer.render(scene, camera);
        }

        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }

        //A function which determines which way the user is moving
        function onDocumentKeyDown(e) {
            if (gamePaused == false) {
                if (inJumpscare == false) {
                    movement = 0;
                    var keyCode = e.which || e.keyCode; //Gets the key code
                    //Sets the direction the user is moving based on which key the user pressed
                    if (keyCode == 87) movement = "forward";
                    else if (keyCode == 65) movement = "left";
                    else if (keyCode == 68) movement = "right";
                    else if (keyCode == 83) movement = "backward";
                    else if (keyCode == 70) { //If the user clicks F then toggle the light intensity on and off
                        play('sounds/click.mp3')
                        spotLightOn = !spotLightOn;
                        if (spotLightOn == false) {
                            light.intensity = 0;
                            spotLightOn = false;
                        }
                        else {
                            light.intensity = 6;
                            spotLightOn = true;
                        }
                    }
                    if (movement != 0) moveAround(); //If the user is moving then call the moveAround function
                }

            }
        }

        //Function which moves the user & handles collision
        function moveAround() {
            if (stamina <= 10) {
                speed = 1;
            }
            else if (stamina > 10) {
                speed = 2;
            }
            moving = true; //Sets the boolean whether the user was moving or not to true
            oldCamera = camera.clone(); //Create a clone of the camera
            //Translates the user using a specific speed based on which movement has been triggered
            if (movement == "forward") camera.translateZ(-speed);
            if (movement == "left") camera.translateX(-speed);
            if (movement == "backward") camera.translateZ(speed);
            if (movement == "right") camera.translateX(speed);

            for (let t = 0; t < starShards.length; t++) { //For the length of the array containing all of the trees
                if (calcPointDistance(camera.position, starShards[t].position) <= 4) { //4
                    starHit = t; //Sets boolean "hit" to true
                }
            }
            for (let t = 0; t < trees.length; t++) { //For the length of the array containing all of the trees
                if (calcPointDistance(camera.position, trees[t].position) <= 2) { //Calcs whether the camera and a
                    //certain tree are too close together
                    hit = true; //Sets boolean "hit" to true
                }
            }
            //Src: https://github.com/TovAqulic/threejs_collision_issue
            if (hit == true) { //If the user has collided with a tree then move the user in the opposite direction that
                //the tree they collided with is in
                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);
                hit = false; //Sets the "hit" boolean to false
            }
            //Src: https://github.com/TovAqulic/threejs_collision_issue
            if (starHit != -1) {
                play('sounds/starAscension.wav');
                movingStarShard.push(starShards[starHit]);
                starShards.splice(starHit, 1);
                starHit = -1; //Sets the "hit" boolean to false
                starsCollected += 1;
                starGroup.children[starsCollected].material.color.setHex(0xffff00);
                if (starsCollected == 5) {
                    starGroup.children[0].material.color.setHex(0xffff00);
                    //  gameOver(1);
                    gameState = 1;

                }
            }
            //If the user is out of bounds then move them in the opposite direction of the way they are trying to walk
            else if (camera.position.x < -380 || camera.position.x > 380 || camera.position.z < -380 || camera.position.z > 380) {
                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);
            }
        };


        //Function which adds stars to the scene
        function addStars() {
            for (let i = 0; i < 50; i++) { //For 50 iterations 
                //Make a geometry, material, and mesh of a point
                var dotGeometry = new THREE.Geometry();
                dotGeometry.vertices.push(new THREE.Vector3(0, 0, 0));
                var dotMaterial = new THREE.PointsMaterial({ size: Math.random() * 6, sizeAttenuation: false });
                var dot = new THREE.Points(dotGeometry, dotMaterial);
              
                //Give the star a random x and z position
                let x = newRandom(0, 450);
                let z = newRandom(0, 450);
                let y;
                
                //Determine the y position for the point
                if (x > 350 || x < -350 || z > 350 || z < -350) {
                    y = Math.random() * 350 + 40;
                }
                else {
                    y = 350;
                }
                dot.position.set(x, y, z);
                //Randomly add the point geometry to either the shooting stars array or the pretty stars array
                if (Math.random() > .8) {
                    shootingStars.push(dot);
                }
                else {
                    prettyStars.push(dot);
                }
                scene.add(dot);
            }
            addShootingStar(); //Calls shooting star function on any points that may have been added to the shooting star array
        }

        //Function which moves points in the shooting stars array in a random direction 
        function addShootingStar() {
            for (let i = 0; i < shootingStars.length; i++) { //For the length of the shooting stars array

                //Give the x and z a random position between two limits
                let x = newRandom(2, 5);
                let z = newRandom(2, 5);
              
                //Add the new x and z positions to both of the star direction arrays
                starXDirs.push(x);
                starZDirs.push(z);
            }
        }


        //Function which creates stamina bar
        function initStaminaBar() {
            //Creates a geometry, a material, and am esh for the variable
            const geometry = new THREE.PlaneGeometry(100, 5);
            const hmaterial = new THREE.MeshBasicMaterial({ color: 0x5CFF5C, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, hmaterial);
            mesh.position.set(windowWidth - (windowWidth * .65), windowHeight - (windowHeight * 1.42), 0);
            mesh.scale.set(2.015 * (stamina - 5) * .01, 4); //Scales the mesh based on the stamina of the user
            sceneHUD.add(mesh);//Adds stamina bar to the mesh and returns it
            return mesh;
        }


        // Function calls
        let staminaBar = initStaminaBar();
        let monster = initMonster();
        // initCursor();
        makeModels();
        initLightning();
        initWorld();
        initFog();
        initTerrain();
        placeJumpscares(); //Places jumpscares around map
        initMoon();
        initTrees(0, 15);
        initStarShards(5);
        initBody();
        let light = initFlashLight();
        let firePosition = randomizePositions(300, 50);
        let campfire = new CampFire(firePosition, heightLimit);

        for (let i = 0; i < 3; i++) { //Creates three hearts and adds them to the scene
            initHeartIcon(heartPositions[i]);
        }

        let starBorderGroup = initStarIcon(0x000000, .6);
        let starGroup = initStarIcon(0x000000, .5);
        sceneHUD.add(starGroup); //Adds star icon to the hud scene
        sceneHUD.add(starBorderGroup)//Adds black outline of a star to the hud scene
  

        animate();
        render();


    </script>
</body>

</html>