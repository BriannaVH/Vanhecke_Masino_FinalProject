<html>

<head>
    <title>Final Project</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(14, 1, 38, 0.789);
            color: white;
            font-family: "Serif", "Georgia", monospace;
        }

        #instructions {
            position: fixed;
            width: 100%;
            height: 100%;

            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;

            text-align: center;
            top: -30%;
            font-size: 25px;
            font-family: "Serif", "Georgia", monospace;
            cursor: pointer;
        }

        .dropbtn {
            min-width: 160px;
            background-color: #F3DEFF;
            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 35%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
        }



        .button {
            min-width: 160px;
            background-color: #F3DEFF;
            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 55%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
        }

        .greenText {
            min-width: 160px;
            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 35%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
            background-color: green;
        }

        .blueText {
            min-width: 160px;

            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 35%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
            background-color: rgb(255, 191, 0);
        }

        .redText {
            min-width: 160px;
            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 35%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
            background-color: red;
        }

        .greyText {
            min-width: 160px;
            color: black;
            padding: 16px;
            font-size: 25px;
            border: none;
            cursor: pointer;
            position: fixed;
            left: 35%;
            top: 65%;
            font-family: "Serif", "Georgia", monospace;
            background-color: rgba(97, 89, 89, 0.637);
        }
    </style>
</head>

<!-- Zara Masino & Brianna Van Hecke -->
<!-- We did the head bob & made the user casts a shadow  -->



<div id="blocker">
    <div id="instructions">
        <p style="font-size:80px">
            Monster Bash
        </p>
        <p>
            Instructions<br />
            <br />
            More Instructions
        </p>
    </div>

    <div class="dropdown">
        <div id = "selectbutton">
        <select class="dropbtn" name="difficulty" id = "selectButton2" onchange="this.className=this.options[this.selectedIndex].className"
            class="greenText">>

            <option class="greyText" disabled="disabled" selected="selected">Choose Difficulty</option>
            <option class="greenText" value="easy">Easy</option>
            <option class="blueText" value="medium">Medium</option>
            <option class="redText" value="hard">Hard</option>
        </select>
        </div>
        <div id="button">
            <button class="button">Start</button>
        </div>

    </div>
</div>

<body>


    <canvas id="myCanvas" width="800" height="800"></canvas>
    <script src="Perlin.js"></script>
    <script type="module">

        //Imports
        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { PointerLockControls } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/controls/PointerLockControls.js';
        import { LightningStrike } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/geometries/LightningStrike.js';
        import { LightningStorm } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/objects/LightningStorm.js';


        //Variable Declaration
        import { OutlinePass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/OutlinePass.js'
        import { RenderPass } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/RenderPass.js'
        import { EffectComposer } from 'http://cs.merrimack.edu/~stuetzlec/three.js-master/examples/jsm/postprocessing/EffectComposer.js'



        //Variable Declaration
        let scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.lookAt(new THREE.Vector3(0.0, 0.0, 0.0));
        camera.position.set(0, 80, 10);

        scene.add(camera);

        let perlin = new Perlin(); // used for terrain generation
        let loader = new THREE.TextureLoader(); //Texture loader
        let raycaster = new THREE.Raycaster();
        let humanGroup = new THREE.Group(); // used for the body
        let monsterGroup = new THREE.Group(); // used for the body
        let clock = new THREE.Clock();




        const GROUND_SIZE = 1000;
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE), new THREE.MeshLambertMaterial({ color: 0x072302 }));
        ground.rotation.x = - Math.PI * 0.5;
        let currentSceneIndex = 0;
        let currentTime = 0;


        let movementSpeeds = 40;
        let totalObjects = 500;
        let objectSize = 10;
        let colors = [0xFF0FFF, 0xCCFF00, 0xFF000F, 0x996600, 0xFFFFFF, 0xcbbeb5, 0x9003ff, 0x6d9bc3,
            0x87a96b, 0x520520, 0xeaa315, 0x327572, 0xb8888d, 0xcc77dd, 0xbcd4e6, 0xfe6f5e, 0x318ce7, 0xa2a2d0];
        let dirs = [];
        let parts = [];


        let smokeParticles;
        let smokeTexture;
        let smokeMaterial;
        let smokeGeo

        let delta;
        // used in terrain generation
        let peak = 30;
        let smoothing = 200;

        // used for movement and rotation management
        let speed = 2;
        let turnSpeed = .2;

        // used for the head bobbing effect
        let change = 0;
        let sinwave = 0;
        let displacement = 0;

        // used for the cursor placement
        let toggle = 0;

        // used in movement and collision
        let hit = false;
        let moving = false;
        let starHit = -1;
        let starsCollected = 0;
        let lives = 3;
        let spotLightOn = false;
        let gameOverBool = false;
        let intersection = null;


        let trees = [];
        let spheres = [];
        let worldItems = [];
        let stars = [];
        let movingStars = [];

        // used in movement and collision
        let movement;
        let oldCamera;

        // geometries, materials, and meshes
        let worldGeom;
        let worldMat;
        let world;

        let waterGeom;
        let waterMat;
        let water;

        let terrainGeom;
        let terrainMat;
        let terrain;

        let terrainShadowMat;
        let terrainShadow;

        let cursorGeom;
        let cursorMat;
        let cursor;


        let moon;
        let wood = new THREE.MeshPhongMaterial({ color: 0x80471C, map: loader.load("trees/oakwood.jpg") });

        //Colors for sky/sun/moon
        let moonColor = [0xdde2e5];
        let skyColors = [0x000608, 0x072f41, 0x094f6d, 0x436e91, 0x5e88b8, 0x7998bb];

        let spotLight, lightTarget;

        let renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0xADD8E6);//Sets color of renderer
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio); //Sets renderer to the canvas
        renderer.setSize(window.innerWidth, window.innerHeight); //Specifies how much of screen will be rendererd
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true; //Enables shadow map
        renderer.shadowMapSoft = true; //Specifies type of shadow
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;


        var hudCanvas = document.createElement('canvas');
        // Again, set dimensions to fit the screen.
        hudCanvas.width = windowWidth;
        hudCanvas.height = windowHeight;
        // Get 2D context and draw something supercool.
        //  var hudBitmap = hudCanvas.getContext('2d');
        //  hudBitmap.font = "Normal 40px Arial";
        //  hudBitmap.textAlign = 'center';
        //  hudBitmap.fillStyle = "rgba(245,245,245,0.75)";
        //  hudBitmap.fillText('Initializing...', width / 2, height / 2);
        // Create the camera and set the viewport to match the screen dimensions.
        var cameraHUD = new THREE.OrthographicCamera(-windowWidth / 2, windowWidth / 2, windowHeight / 2, -windowHeight / 2, 0, 30);
        // Create also a custom scene for HUD.
        let sceneHUD = new THREE.Scene();
        // Create texture from rendered graphics.
        var hudTexture = new THREE.Texture(hudCanvas)
        hudTexture.needsUpdate = true;
        // Create HUD material.
        var material = new THREE.MeshBasicMaterial({ map: hudTexture });
        material.transparent = true;
        // Create plane to render the HUD. This plane fill the whole screen.
        var planeGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
        var plane = new THREE.Mesh(planeGeometry, material);
        sceneHUD.add(plane);
        // console.log(windowWidth);
        // console.log(windowHeight);
        // const x = width - (width * .8)
        let heartArray = [];
        function makeHeart(x) {
            const y = windowHeight - (windowHeight * .8);
            const heartShape = new THREE.Shape();
            heartShape.moveTo(x + 5, y + 5);
            heartShape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
            heartShape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
            heartShape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19);
            heartShape.bezierCurveTo(x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7);
            heartShape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
            heartShape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);
            const geometry = new THREE.ShapeGeometry(heartShape);
            const hmaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, hmaterial);
            mesh.rotation.z = -3.15;
            mesh.scale.set(2, 2);
            sceneHUD.add(mesh);
            heartArray.push(mesh);
        }

        let composer = new EffectComposer(renderer);

        // pointer lock controls for first person camera movement 
        let controls = new PointerLockControls(camera, document.body); //Enables pointerlock controls

        /* When the user clicks on the button, 
               toggle between hiding and showing the dropdown content */


        // // Close the dropdown if the user clicks outside of it
        // window.onclick = function (event) {
        //     // if (!event.target.matches('.dropbtn')) {
        //     //     console.log("triggered");
        //     //     var dropdowns = document.getElementsByClassName("dropdown-content");
        //     //     var i;
        //     //     for (i = 0; i < dropdowns.length; i++) {
        //     //         var openDropdown = dropdowns[i];
        //     //         if (openDropdown.classList.contains('show')) {
        //     //             openDropdown.classList.remove('show');
        //     //         }
        //     //     }
        //     // }
        //      if (event.target.matches('button')) {
        //         console.log(event.target);
        //         console.log("GOT IN");
        //         instructions.style.display = 'none';
        //         blocker.style.display = 'none';
        //         controls.lock(); //Locks pointerlock controls upon the user clicking
        //     }
        // }

        var e = document.getElementById("selectButton2");
        console.log(e);
        function onChange() {
            var value = e.value;
            var text = e.options[e.selectedIndex].text;
            console.log(value, text);
        }
        e.onchange = onChange;
        onChange();

        document.getElementById("button").onclick = function () {
            console.log("hello");
            instructions.style.display = 'none';
            blocker.style.display = 'none';
            controls.lock(); //Locks pointerlock controls upon the user clicking
        };


        // document.addEventListener('click', function () {
        //     if (document.getElementById("button") == true) {
        //         instructions.style.display = 'none';
        //         blocker.style.display = 'none';
        //         controls.lock(); //Locks pointerlock controls upon the user clicking
        //     }

        // });

        controls.addEventListener('unlock', function () {

            blocker.style.display = 'block';
            instructions.style.display = '';
            controls.unlock();

        });

        initLightning();
        // animate();

        function initLightning() {

            createStormScene(camera, terrain, 450);


            scene.userData.timeRate = 4;


            scene.userData.lightningColorRGB = [
                scene.userData.lightningColor.r * 255,
                scene.userData.lightningColor.g * 255,
                scene.userData.lightningColor.b * 255
            ];

            scene.userData.outlineColorRGB = [
                scene.userData.outlineColor.r * 255,
                scene.userData.outlineColor.g * 255,
                scene.userData.outlineColor.b * 255
            ];

            //createScene();

        }
        function createOutline(scene, objectsArray, visibleColor) {

            const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, scene.userData.camera, objectsArray);
            outlinePass.edgeStrength = 2.5;
            outlinePass.edgeGlow = 0.7;
            outlinePass.edgeThickness = 2.8;
            outlinePass.visibleEdgeColor = visibleColor;
            outlinePass.hiddenEdgeColor.set(0);
            composer.addPass(outlinePass);

            scene.userData.outlineEnabled = true;

            return outlinePass;

        }



        //

        function createStormScene(camera, terrain, terrainSize) {

            // scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);

            scene.userData.canGoBackwardsInTime = false;

            scene.userData.camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 20, 10000);

            // Lights

            // scene.add(new THREE.AmbientLight(0x444444));

            // const light1 = new THREE.DirectionalLight(0xffffff, 0.5);
            // light1.position.set(1, 1, 1);
            // scene.add(light1);

            // const posLight = new THREE.PointLight(0x00ffff);
            // posLight.position.set(0, 100, 0);
            // scene.add(posLight);

            // Ground



            scene.userData.camera.position.set(0, 0.2, 1.6).multiplyScalar(GROUND_SIZE * 0.5);


            //scene.add(ground);

            // Storm

            scene.userData.lightningColor = new THREE.Color(0xB0FFFF);
            scene.userData.outlineColor = new THREE.Color(0x00FFFF);

            scene.userData.lightningMaterial = new THREE.MeshBasicMaterial({ color: scene.userData.lightningColor });

            const rayDirection = new THREE.Vector3(0, - 1, 0);
            let rayLength = 0;
            const vec1 = new THREE.Vector3();
            const vec2 = new THREE.Vector3();

            scene.userData.rayParams = {

                radius0: 1,
                radius1: 0.5,
                minRadius: 0.3,
                maxIterations: 7,

                timeScale: 1,
                propagationTimeFactor: .01,
                vanishingTimeFactor: .7,
                subrayPeriod: .1,
                subrayDutyCycle: .7,
                deathTime: 1,

                maxSubrayRecursion: 3,
                ramification: 3,
                recursionProbability: 0.4,

                roughness: 0.85,
                straightness: 0.65,

                onSubrayCreation: function (segment, parentSubray, childSubray, lightningStrike) {

                    //console.log("gets in here1");
                    lightningStrike.subrayConePosition(segment, parentSubray, childSubray, 0.6, 0.6, 0.5);

                    // Plane projection

                    rayLength = lightningStrike.rayParameters.sourceOffset.y;
                    vec1.subVectors(childSubray.pos1, lightningStrike.rayParameters.sourceOffset);
                    const proj = rayDirection.dot(vec1);
                    vec2.copy(rayDirection).multiplyScalar(proj);
                    vec1.sub(vec2);
                    const scale = proj / rayLength > 0.5 ? rayLength / proj : 1;
                    vec2.multiplyScalar(scale);
                    vec1.add(vec2);
                    childSubray.pos1.addVectors(vec1, lightningStrike.rayParameters.sourceOffset);

                }

            };



            const storm = new LightningStorm({


                size: GROUND_SIZE,
                minHeight: 400,//Determine how low the lightning can generate at
                maxHeight: 800,
                maxSlope: 0.6,
                maxLightnings: 1,
                lightningMinPeriod: 20,
                lightningMaxPeriod: 30,


                lightningParameters: scene.userData.rayParams,

                lightningMaterial: scene.userData.lightningMaterial,

            });

            scene.add(storm);
            //  console.log(storm);

            // Compose rendering

            composer.passes = [];
            composer.addPass(new RenderPass(scene, scene.userData.camera));
            createOutline(scene, storm.lightningsMeshes, scene.userData.outlineColor);

            scene.userData.render = function (time) {
                // console.log("gets in here2");

                storm.update(time);

                if (scene.userData.outlineEnabled) {

                    composer.render();

                } else {

                    renderer.render(scene, scene.userData.camera);

                }

            };

            //  return scene;

        }



        //Initializes Cursor
        function initCursor() {
            cursorGeom = new THREE.SphereGeometry(0.02, 16, 16); //Creates a cursor geom
            cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); //Cursor material with color
            cursor = new THREE.Mesh(cursorGeom, cursorMat); //Creates mesh
            scene.add(cursor); //Adds cursor to the scene
            spheres.push(cursor); //Adds cursor to the spheres array
        }

        //Initializes the sphere surrounding our "world"
        function initWorld() {
            worldGeom = new THREE.SphereGeometry(550, 32, 32); //Creates world Geometry (is a sphere)
            worldMat = new THREE.MeshBasicMaterial({
                color: 0xADD8E6, //Gives specific color
                wireframe: false,
                side: THREE.DoubleSide, //Gives the sphere two sides so it is visible from inside and outside
                map: loader.load("skies/cloud3.jpg")
            }); //Textures the sphere with clouds

            worldMat.transparent = true; //Makes the world material halfway transparent in order to make the sky look
            //more realistic
            worldMat.opacity = .5;
            world = new THREE.Mesh(worldGeom, worldMat); //Creates world mesh
            world.rotateZ(1.4708); //Rotates world specific amount to avoid the ""
            scene.add(world);
            worldItems.push(world);

        }

        function initFlashLight() {

            spotLight = new THREE.SpotLight(0xffff00, 2, 0, Math.PI * .1, 0, 1);

            spotLight.castShadow = true;
            // spotLight.receiveShadow = true;
            //  spotLight.shadow = new THREE.SpotLightShadow(new THREE.PerspectiveCamera(20, 1, 1, 250));
            spotLight.target = cursor;


            spotLight.shadow.camera.near = 500;
            spotLight.shadow.camera.far = 4000;

            spotLightOn = true;

            camera.add(spotLight);


        }

        //Creates the sun/moon and their corresponding point lights
        function makeLights(hexCode, x, y, z, intensity) {
            renderer.setClearColor(0x000608);//Changes the color of the world to teh 
            //Creates a sphere (sun/moon) and corresponding pointlight and adds them both to the scene

            this.bulbGeometry = new THREE.SphereGeometry(10, 32, 16); //Creates sphere geometry
            this.bulbLight = new THREE.PointLight(hexCode, intensity, 20000); //Creates point light

            this.bulbMat = new THREE.MeshBasicMaterial({ //Creates bulb material for the light and customizes it
                emissive: 0x880808,
                emissiveIntensity: 1,
                color: 0x880808
            });

            this.bulbLight.add(new THREE.Mesh(this.bulbGeometry, this.bulbMat)); //Adds bulb geometry & bulb light to the point light
            this.bulbLight.position.set(x, y, z); //Positions the light 
            this.bulbLight.castShadow = true; //Casts shadow from the light
            this.bulbLight.shadow.bias = - 0.0005; // Reduces self-shadowing on double-sided objects
            this.bulbLight.shadow.radius = 8; //Increases smoothness of the shadows
            this.bulbLight.shadow.mapSize.width = 2048; //Increases resolution of shadows
            this.bulbLight.shadow.mapSize.height = 2048;
            scene.add(this.bulbLight); //Adds point light to the scene
        }


        function makeFoggy() {
            const near = 30;
            const far = 100;
            const color = 0xff0000;
            scene.fog = new THREE.FogExp2(color, 0); //.005

        }

        //Creates terrain and water that will appear in the scene
        function createLandAndWater() {

            waterGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256); //Creates water geom
            waterMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, //Sets color to white
                map: loader.load('water/water.jpg'), //Loads in water texture
                side: THREE.DoubleSide//Makes doublesided
            });

            waterMat.opacity = .7; //Makes the opacity to 70%
            waterMat.transparent = true;
            water = new THREE.Mesh(waterGeom, waterMat);//Creates water mesh

            water.rotation.x = -Math.PI / 2; //Rotates water so that it appears on the ground surface
            water.position.y = -25;//Positions the water so that only some water will appear to the user depending on
            //how hilly a certain part is
            water.receiveShadow = true; //Water can receive shadows
            scene.add(water); //Adds water to scene
            worldItems.push(water); //Adds water to worldItems so that the cursor will recognize the water and not disappear

            terrainGeom = new THREE.PlaneBufferGeometry(800, 800, 256, 256); //Creates terrain geometry
            terrainMat = new THREE.MeshPhysicalMaterial({
                color: 0x1a2e18,
                map: loader.load('land/sand3.jpg'), //Loads in terrain texture
                side: THREE.DoubleSide
            }); //Makes terrain doublesided
            terrain = new THREE.Mesh(terrainGeom, terrainMat); //Creates terrain mesh
            terrain.rotation.x = -Math.PI / 2;//Rotates terrain so that it appears on the ground surface

            scene.add(terrain);

            //Makes shadows not completely opaque on the terrain.
            terrainShadowMat = new THREE.ShadowMaterial(); //Creates shadow material
            terrainShadowMat.opacity = 0.5; //The terrain shadow is 50% opaque which allows individuals to see the terrain
            //underneath
            terrainShadow = new THREE.Mesh(terrainGeom, terrainShadowMat); //Creates shadow mesh
            terrainShadow.receiveShadow = true;//Shadow mesh receives the shadow
            terrainShadow.castShadow = true;//Shadow mesh casts shadow
            terrainShadow.position.copy(terrain.position);//Copies terrains position
            terrainShadow.rotation.copy(terrain.rotation);//Copies terrains rotation
            scene.add(terrainShadow);


            //src: http://www.stephanbaker.com/post/perlinterrain/
            var vertices = terrain.geometry.attributes.position.array;
            for (var i = 0; i <= vertices.length; i += 3) {
                vertices[i + 2] = peak * perlin.noise(
                    vertices[i] / smoothing,
                    vertices[i + 1] / smoothing
                );
            }
            terrain.geometry.attributes.position.needsUpdate = true;
            terrain.geometry.computeVertexNormals();


            terrain.castShadow = true;
            worldItems.push(terrain);
        }

        //Creates sun and moon bulblights
        function createMoon() {
            moon = new makeLights(moonColor[0], 0, 280, 0, .1);
            //Creates both lights and geometries

            worldItems.push(moon.bulbLight);
        }

        //This function randomly returns a true or false value or a number between 0 and 10 in order to help randomize certain customizations
        function random() {
            let randomNumber = Math.round(Math.random() * 10); //Creates a random number between 0 and 10
            if (randomNumber % 2 == 0) { //If the random number is even
                return true;
            }
            else {
                return false;
            }
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that creates a tree
        function TreeBuilder(string, params, texture) {
            // The characteristics of the tree
            this.string = string;
            this.params = params;
            this.texture = texture;

            //Function that builds the tree
            this.build = function () {
                //Init params for the tree
                let state = {
                    bRadius: this.params.branchRadius,
                    bLength: this.params.branchLength,
                    bReduction: this.params.branchReduction,
                    bMinRadius: this.params.branchMinRadius,
                    position: new THREE.Vector3(0, 0, 0),
                    rotation: new THREE.Quaternion()
                }
                // The stack used to keep track of where elements go 
                let stateStack = [];

                //Set the materials properites for the branches and leaves
                let tree = new THREE.Object3D();
                let branchMaterial = this.texture;


                // Create a random number to determine if the tree has leaves or not and what 
                //shape leaf it will be
                let random = Math.random();

                // For the length of the grammar string
                for (let i = 0; i < this.string.length; i++) {
                    // Get the character and create a random number
                    let char = this.string.charAt(i);

                    let rand = Math.random();
                    // If the character is F, build 0, 1, or 2 branches depending on rand
                    if (char == "F") {
                        if (rand < .75) {
                            tree.add(buildBranch(state, branchMaterial));
                        }
                        else if (rand > .95) {
                            tree.add(buildBranch(state, branchMaterial));
                            tree.add(buildBranch(state, branchMaterial));
                        }
                    }

                    //Reassign rand
                    rand = Math.random();
                    // For the z axis
                    // If the character is +, rotate the branch 180 or -180 degrees depending on rand
                    if (char == "+") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -this.params.delta * Math.PI / 180));
                        }
                    }

                    // Reassign rand
                    rand = Math.random();
                    // For the y axis
                    // If the character is >, rotate the branch 180 or -180 degrees depending on rand
                    if (char == ">") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.params.delta * Math.PI / 180));
                        }
                    }
                    // Reassing rand
                    rand = Math.random();
                    // For the x axis
                    // If the character is <, rotate the branch 180 or -180 degrees depending on rand
                    if (char == "<") {
                        if (rand > .5) {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -this.params.delta * Math.PI / 180));
                        }
                        else {
                            state.rotation.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.params.delta * Math.PI / 180));
                        }
                    }
                    // If the characters are [ or ], pop or push a clone of the state respectively 
                    if (char == "[") {
                        stateStack.push(cloneState(state));
                        state.bRadius = (state.bRadius - state.bReduction) > state.bMinRadius ? (state.bRadius - state.bReduction) : state.bRadius;
                    }
                    if (char == "]") {
                        state = cloneState(stateStack.pop());
                    }

                }
                // Turn on shadows for the tree
                tree.castShadow = true;
                // Return the tree
                return tree;
            }
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that builds a branch 
        function buildBranch(state, material) {
            // Set the rotation to state rotation
            var transform = new THREE.Quaternion();
            transform.multiply(state.rotation);

            // Set the position to be appropriate for the tree
            var position = new THREE.Vector3(0.0, state.bLength / 2, 0.0);
            // Apply the rotation of the state
            position.applyQuaternion(state.rotation);
            // Add the branch position to the tree position
            state.position.add(position);

            // Create the branch geometry and mesh
            var geometry = new THREE.CylinderBufferGeometry(state.bRadius, state.bRadius, state.bLength, 16);
            var branch = new THREE.Mesh(geometry, material);
            // Copy the rotation and position of the state
            branch.quaternion.copy(state.rotation);
            branch.position.copy(state.position);

            // Add the position to the state
            state.position.add(position);
            //Turn on shadows for the branch
            branch.castShadow = true;
            //Return the branch
            return branch;

        }



        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that clones the current state
        function cloneState(state) {
            // Return the clone
            return {
                bRadius: state.bRadius,
                bLength: state.bLength,
                bReduction: state.bReduction,
                bMinRadius: state.bMinRadius,
                position: new THREE.Vector3().copy(state.position),
                rotation: new THREE.Quaternion().copy(state.rotation)
            }
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that creates parameters for a tree
        function Params(axiom, iterations, delta, branchLength,
            branchRadius, branchReduction, branchMinRadius) {
            this.axiom = axiom ? axiom : "F";
            this.iterations = iterations ? iterations : 4;
            this.delta = delta ? delta : 25;
            this.branchLength = branchLength ? branchLength : 3;
            this.branchRadius = branchRadius ? branchRadius : 0.4;
            this.branchReduction = branchReduction ? branchReduction : 0.1;
            this.branchMinRadius = branchMinRadius ? branchMinRadius : 0.1;
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that reads through the rules and reformats them for use
        function parseRules(rules) {
            var result = {};
            // Split on the new line
            rules.split("\n").forEach(function (a) {
                // For each line, split at the = sign
                var line = a.split("=");
                // If the result is not the first thing in line
                if (!result[line[0]]) {
                    // Empty out result at that index
                    result[line[0]] = [];
                }
                // Push the line to result
                result[line[0]].push(line[1])
            });
            // Return the result
            return result;
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that rewrites the rules
        function Rewriter(rules) {

            this.rules = rules;

            this.rewrite = function (params) {
                // Get the axiom of the params
                let result = params.axiom;
                // For each param
                for (let i = 0; i < params.iterations; i++) {
                    let localResult = "";
                    // For each axiom
                    for (let j = 0; j < result.length; j++) {
                        // Get that character and set it to the rule of that character
                        let char = result.charAt(j);
                        let rule = this.rules[char];
                        // If the rule is undefined, add the result of getrule 
                        if (rule !== undefined) {
                            localResult += getRule(rule);
                            // Else add the character
                        } else {
                            localResult += char;
                        }
                    }
                    // Set result to localresult
                    result = localResult;
                }
                //Return result
                return result;
            };
        }

        //src: https://github.com/NekoStark/lsystem-threejs-unifi
        // A function that chooses which portion of the rule to use based on probability
        function getRule(rules) {
            var probability = rules.length;
            var choice = probability > 1 ?
                parseInt((((Math.random() * probability) + 1) * 1000) / 1000) - 1 : 0;

            // Return which rule to use
            return rules[choice];
        }

        //https://codepen.io/Xanmia/pen/nqyMgJ
        //This link helped us identify how to create particle explosions in our code
        //This function actually creates the particles that will explode whenever the camera collides with an object
        function ExplodeAnimation(x, y, z) {
            var geometry = new THREE.Geometry(); //Create a geometry

            for (let i = 0; i < totalObjects; i++) { //Iterates a set number of times. Creates another particle each time
                var vertex = new THREE.Vector3(x, y, z); //Creates a new vector 3 with the given x y z values
                geometry.vertices.push(vertex);//Adds the vector as vertices to the geomety
                //Creates different directions the particles will explode off into based on the particles position
                dirs.push({ x: (Math.random() * movementSpeeds) - (movementSpeeds / 2), y: (Math.random() * movementSpeeds) - (movementSpeeds / 2), z: (Math.random() * movementSpeeds) - (movementSpeeds / 2) });
            }

            var colorsRand = Math.round(Math.random() * 17) //Generates a random number that will be used to randomly
            //select a color from the color array
            var material = new THREE.PointsMaterial({ size: objectSize, color: 0xFFFF00 }); //Create point material
            //with random color
            this.object = new THREE.Points(geometry, material);; //make a mesh as the object of this function
            scene.add(this.object); //Adds the particle object to the scene

            this.update = function () { //Function which adds all of these particles to the scene and sends them off in random
                //directions
                var pCount = totalObjects; //Set pcount equal to the number of total particles we want
                while (pCount--) { //decrement pcount
                    var particle = this.object.geometry.vertices[pCount] //Creates a particle using the vertices of the object
                    //Continuously increments the x,y,z position of the particle
                    particle.y += dirs[pCount].y;
                    particle.x += dirs[pCount].x;
                    particle.z += dirs[pCount].z;
                }
                this.object.geometry.verticesNeedUpdate = true;
            }
        }

        //This function checks the position of the sun and moon and changes the colors/intensity of either of the two
        //objects based on height
        function checkPositions(moon) {
            let moonLight = moon.bulbLight;

            //If the moon is a specific height then modify the color of the renderer, the world (sphere surrounding the terrain),
            // & change the intensity of the moon
            if (moonLight.position.y > 300) {
                renderer.setClearColor(skyColors[0]);
                world.material.color.setHex(skyColors[0]);
                moonLight.intensity = .8;
            }
            else if (240 <= moonLight.position.y && moonLight.position.y < 300) {
                renderer.setClearColor(skyColors[1]);
                world.material.color.setHex(skyColors[1]);
                moonLight.intensity = .7;
            }
            else if (180 <= moonLight.position.y && moonLight.position.y < 240) {
                moonLight.intensity = .6;
            }
            else if (120 <= moonLight.position.y && moonLight.position.y < 180) {
                renderer.setClearColor(skyColors[2]);
                world.material.color.setHex(skyColors[2]);
                moonLight.intensity = .5;
            }
            else if (moonLight.position.y < 120 && moonLight.position.y > -.5) {
                moonLight.intensity = .4;
            }
            //Turn off the moon point light completely if it is below the terrain
            else if (moonLight.position.y < -.5) {
                moonLight.intensity = 0;
            }
        }

        //src:https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_collision_detection
        function calcPointDistance(point, point2) {
            //This calculates the distance of two points based on the distance formula
            const distance = Math.sqrt(
                (point.x - point2.x) * (point.x - point2.x) +
                (point.y - point2.y) * (point.y - point.y) +
                (point.z - point2.z) * (point.z - point2.z)
            )
            return distance; //Returns distance
        }

        //Function that randomizes a position (x,y,z) coordinate in the terrain
        function randomizePositions() {

            let rayHeight = new THREE.Raycaster();
            let rayDirection = new THREE.Vector3(0, -1, 0);//Gives direction for raycaster
            //Below recalculates the world matrix of the objects and their descendants on the current frame
            terrain.updateMatrixWorld(true);
            scene.updateMatrixWorld(true);

            let treePos = new THREE.Vector3();

            //Gives x and z a random position within the bounds of the terrain
            let xPos = Math.random() * (380 - 5) + 5;
            let zPos = Math.random() * (380 - 5) + 5;
            let yPos = 100;//Gives the y pos a set point above the terrain

            //Randomizes whether the x and z position were negative
            if (random() == true) {
                xPos *= -1;
            }
            if (random() == true) {
                zPos *= -1;
            }

            treePos.set(xPos, yPos, zPos);//Sets treePosition to the randomized x,y and z coordinates
            rayHeight.ray.set(treePos, rayDirection.normalize()); //Has ray cast downwards from the treePos
            let intersectHeight = rayHeight.intersectObject(terrainShadow); //Finds where the ray intersects with the 
            //terrain
            if (intersectHeight.length != 0) {
                yPos = intersectHeight[0].point.y; //Sets the yPos to where the ray intersected with the terrain
            }
            treePos.set(xPos, yPos, zPos);//Sets treePosition to the randomized x,y and z coordinates

            return treePos;
        }


        let x = 0;
        let y = 50;

        function makeSmoke() {

            smokeTexture = loader.load('skies/smoke1.png');
            smokeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, map: smokeTexture, transparent: true, side: THREE.DoubleSide });
            smokeGeo = new THREE.DodecahedronGeometry(30, 0);
            //smokeMaterial.opacity
            // smokeMaterial.receiveShadow = false;
            smokeParticles = [];


            let eyesTexture = loader.load('skies/eyestra.png');
            let eyesGeom = new THREE.PlaneGeometry(40, 40);
            let eyesMat = new THREE.MeshBasicMaterial({ transparent: true, map: eyesTexture, side: THREE.DoubleSide });
            let eyes = new THREE.Mesh(eyesGeom, eyesMat);
            //  scene.add(eyes);
            eyes.position.set(0, 70, 30);
            monsterGroup.add(eyes);


            let smileTexture = loader.load('skies/download.png');
            let smileGeo = new THREE.PlaneGeometry(40, 40);
            let smileMat = new THREE.MeshBasicMaterial({ transparent: true, map: smileTexture, side: THREE.DoubleSide });
            let smile = new THREE.Mesh(smileGeo, smileMat);
            //scene.add(smile);
            smile.position.set(0, 35, 30);
            monsterGroup.add(smile);


            smokeParticles = [];

            for (let p = 0; p < 40; p++) {

                x = Math.random() * 40;
                y = Math.random() * 50;

                if (random() == true) {
                    x *= -1;
                }
                if (random() == true) {
                    y *= -1;
                }
                y = y + 50;

                var particle = new THREE.Mesh(smokeGeo, smokeMaterial);

                //particle.opacity = .1;
                let rotation = Math.random() * 1000;
                if (random() == true) {
                    rotation *= -1;
                }
                particle.position.set(x, y, 0);
                particle.rotation.z = rotation;
                //  console.log(rotation, 'rotation');
                scene.add(particle);
                smokeParticles.push(particle);
                monsterGroup.add(particle);
            }


            scene.add(monsterGroup);

            console.log(monsterGroup, 'monster group');
        }

        //    makeSmoke();


        function evolveSmoke() {
            var sp = smokeParticles.length;
            while (sp--) {
                smokeParticles[sp].rotation.z += (delta * 10);
                //      smokeParticles[sp].rotation.y += (delta * 0.5);
            }
        }


        function makeStars(numStars) {



            for (let i = 0; i < numStars; i++) {
                let position = randomizePositions();

                const geometry = new THREE.SphereGeometry(5, 32, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xffff00, shininess: 100, specular: 0xffff00, emissive: 0xffff00, reflectivity: 1 });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(position.x, position.y, position.z);
                stars.push(sphere);
                worldItems.push(sphere);
                scene.add(sphere);

            }



        }

        // A function that makes the trees for the scene. There are 3 types of wood and 3 grammars
        function makeTrees() {
            //Iterates for 30 times
            for (let i = 0; i < 30; i++) {
                let params;
                let rules;
                //Make oak trees for 10 iterations
                if (i < 10) {
                    params = new Params("F", 2, 22.5, 25, Math.round(Math.random() * 2));
                    rules = parseRules("F=F[+F]F[F>>][<F]\nF=F[+F]F[+<<F][F>]");
                }
                //Make red wood trees for the next 10 iterations
                else if (i >= 20) {
                    params = new Params("F", 3, 15, 15, Math.round(Math.random() * 2));
                    rules = parseRules("F=F>[<+F]F[+F>]<F\nF=F>[+F^>^]F\nF=F[+F>]F>");
                }
                //Make birch trees for the last 10 iterations
                else {
                    params = new Params("F", 2, 30, 20, Math.round(Math.random() * 2));
                    rules = parseRules("F=F[+F]F[F>>][<F]\nF=F[+F]F[+<<F][F>]");
                }
                let rewriter = new Rewriter(rules); //Choose which rule to use based on some probability out of the rules 
                //written in the string
                let string = rewriter.rewrite(params); //Returns which rules were selected
                let positionTree = randomizePositions(); //Randomizes position of the tree
                let newTree = new TreeBuilder(string, params, wood).build(); //Builds tree with rules, params, and specific texture
                newTree.position.set(positionTree.x, positionTree.y, positionTree.z);//Sets position of tree

                //Enables shadows for tree
                newTree.castShadow = true;
                newTree.receiveShadow = true;
                //Pushes tree created onto the worldItems array and trees array
                worldItems.push(newTree);
                trees.push(newTree);

                scene.add(newTree);
            }
        }

        //Function to make the body of the body that casts a shadow
        function makeBody() {

            //Creates material that will be used for each body part
            let wholeBodyMaterial = new THREE.MeshPhongMaterial({
                colorWrite: false, //Makes the material invisible
                depthWrite: false
            });

            //Creates head mesh, positions it, and adds it to the group for the body
            let headGeometry = new THREE.SphereGeometry(4, 32, 32);
            let headMaterial = wholeBodyMaterial;
            let head = new THREE.Mesh(headGeometry, wholeBodyMaterial);
            head.castShadow = true;
            head.receiveShadow = true;
            humanGroup.add(head);
            head.position.set(0, 2, 0);

            //Creates body mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let bodyGeometry = new THREE.BoxGeometry(3, 8, 3)
            let bodyMaterial = wholeBodyMaterial;
            let body = new THREE.Mesh(bodyGeometry, wholeBodyMaterial)
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.set(0, -4, 0);
            humanGroup.add(body)

            //Creates the left arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let leftArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            let leftArmMaterial = wholeBodyMaterial;
            let leftArm = new THREE.Mesh(leftArmGeometry, wholeBodyMaterial)
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.rotateZ(-Math.PI / 3);
            leftArm.position.set(-3.3, -3.5, 0);
            humanGroup.add(leftArm);

            //Creates the right arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let rightArmGeometry = new THREE.BoxGeometry(1.2, 10, 1.2)
            let rightArmMaterial = wholeBodyMaterial;
            let rightArm = new THREE.Mesh(rightArmGeometry, wholeBodyMaterial)
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.rotateZ(Math.PI / 3);
            rightArm.position.set(3.3, -3.5, 0);
            humanGroup.add(rightArm);

            //Creates the right leg mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let rightLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            let rightLegMaterial = wholeBodyMaterial;
            let rightLeg = new THREE.Mesh(rightLegGeometry, wholeBodyMaterial)
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            rightLeg.rotateZ(Math.PI / 6);
            rightLeg.position.set(3.3, -12, 0);
            humanGroup.add(rightLeg);

            //Creates the left arm mesh, positions it relative to the rest of the body, and adds it to the group for the body
            let leftLegGeometry = new THREE.BoxGeometry(2, 10, 2)
            let leftLegMaterial = wholeBodyMaterial;
            let leftLeg = new THREE.Mesh(leftLegGeometry, wholeBodyMaterial)
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            leftLeg.rotateZ(-Math.PI / 6);
            leftLeg.position.set(-3.3, -12, 0);
            humanGroup.add(leftLeg);


            scene.add(humanGroup);

        }

        let previousPos = [];
        previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z));
        let caught = false;
        let distance = 25;
        let timer = 0;
        let monsterSpeed = .08;
        let stamina = 50;
        let fitness = .5;
        let gameTime = 0;

        //The animate function is a function which is continuously called for every frame of the program
        function animate() {
            delta = clock.getDelta();
            gameTime += delta;
            if (gameTime > 1) {
                monsterSpeed -= .01;
                gameTime = 0;
            }
            if (moving == true) {
                stamina -= fitness;
                //console.log("losing stamina ", stamina);
                scene.fog.density += .00003;

            }
            else if (stamina < 50) {
                stamina += fitness * 5;
                console.log("recovering stamina ", stamina);
                scene.fog.density -= .00003 * 5;
            }
            // console.log(delta);
            if (caught == false) {
                if (calcPointDistance(camera.position, previousPos[previousPos.length - 1]) != 0) {
                    //   console.log("INNIT ", previousPos);
                    previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z))
                }

                if (previousPos.length > distance) {
                    timer += delta;
                    if (timer > monsterSpeed) {
                        timer = 0;
                        monsterGroup.position.set(previousPos[0].x, previousPos[0].y, previousPos[0].z);
                        monsterGroup.lookAt(camera.position);
                        previousPos.shift();
                        distance -= 1;
                        if (calcPointDistance(monsterGroup.position, camera.position) < 30) {
                            console.log("caught");
                            caught = true;
                        }
                    }
                }

            }
            else if (caught == true) { //Calcs whether the camera and a
                //certain tree are too close together
                if (gameOverBool == false) {
                    // hit = true; //Sets boolean "hit" to true
                    lives -= 1;
                    heartArray[lives].material.color.set(0x000000);
                    previousPos = [];
                    previousPos.push(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z));
                    distance = 25;
                    caught = false;

                }
                if (lives == 0) {
                    gameOver(0);
                    gameOverBool = true;
                }
            }
            evolveSmoke();

            if (movingStars.length != 0) {
                for (let i = 0; i < movingStars.length; i++) {
                    if (movingStars[i].position.y <= 450) {
                        movingStars[i].translateY(5);

                    }
                    else {
                        parts.push(new ExplodeAnimation(movingStars[i].position.x, movingStars[i].position.y, movingStars[i].position.z));
                        scene.remove(movingStars[i]);
                        movingStars[i].material.dispose();
                        movingStars[i].geometry.dispose();
                        movingStars.splice(i, 1);
                        //parts.pop();

                    }

                }
            }

            var pCount = parts.length;
            while (pCount--) {
                parts[pCount].update(); //Keeps exploding the particles
            }

            //Adds .2 to the change variable and then gets the sin of that value
            change += .1;
            sinwave = Math.sin(change);

            //Creates a raycaster at the camera position that casts in the -y direction
            let ray = new THREE.Raycaster();
            var rayPos = new THREE.Vector3();
            rayPos.set(camera.position.x, camera.position.y, camera.position.z);
            var rayDir = new THREE.Vector3(0, -1, 0);
            ray.set(rayPos, rayDir);
            // keeps track of where the ray intersects the terrain
            let intersect = ray.intersectObject(terrain);
            // if the raycaster is intersecting the terrain
            if (intersect.length != 0) {
                // if the person is moving
                if (moving == true) {
                    // set displacement to our sin*.2 and set the camera y to the intersection y value plus 20 and the displacement
                    displacement = sinwave * .2;
                    camera.position.y = (intersect[0].point.y + 20) + displacement * camera.position.y;
                }
                //otherwise the camera is just 20 above the terrain y so the camera should not bob
                else {
                    camera.position.y = (intersect[0].point.y + 20)
                }
            }
            // in an edge case where the camera cannot find the terrain during loading, set the camera height to 50
            else {
                camera.position.y = 50;
            }


            // if the camera is locked in 
            if (controls.isLocked === true) {
                // set yPos to the camera y minus 5 then set the group to the camera x z and yPos
                let yPos = camera.position.y - 5;
                humanGroup.position.y = (yPos);
                humanGroup.position.z = (camera.position.z);
                humanGroup.position.x = (camera.position.x);
                // make the group rotation match the camera rotation
                humanGroup.setRotationFromMatrix(camera.matrix);

            }
            hudTexture.needsUpdate = true;
            // Render HUD on top of the scene.
            renderer.render(scene, camera);
            renderer.render(sceneHUD, cameraHUD);
            requestAnimationFrame(animate);

        }

        // a function that is called continuously in animate that handles the cursor, hightlighting, and sun/moon rotation
        function render() {
            currentTime += scene.userData.timeRate * clock.getDelta();

            if (currentTime < 0) {

                currentTime = 0;

            }

            scene.userData.render(currentTime);
            // raycast from the camera position in the direction of the camera lookat
            raycaster.set(camera.getWorldPosition(new THREE.Vector3), camera.getWorldDirection(new THREE.Vector3));
            // record the intersection point of the raycaster with any world item
            const intersections = raycaster.intersectObjects(worldItems, true);
            // record the intersection point of the raycaster with any tree
            // set intersections to the first item in itself if it is not null
            intersection = (intersections.length) > 0 ? intersections[0] : null;
            // if toggle is greater than .001 and intersections is not null 
            // toggle detects when the cursor has moved too far from the mouse
            if (toggle > 0.001 && intersection !== null) {
                // update the position of the sphere to be at the point of the raycaster intersection
                spheres[0].position.copy(intersection.point);
                // scale the sphere so that the size is consistant 
                cursor.scale.set(intersection.distance * .5, intersection.distance * .5, intersection.distance * .5)
                toggle = 0;
            }
            //increase toggle by delta
            toggle += clock.getDelta();
            // update the size of the window if needed
            updateSize();
            requestAnimationFrame(render);
            // Rotate the sun and moon around the world 


            checkPositions(moon);
            hudTexture.needsUpdate = true;
            // Render HUD on top of the scene.
            renderer.render(scene, camera);
            renderer.render(sceneHUD, cameraHUD);
            //renderer.render(scene, camera);
        }

        //source: https://threejs.org/examples/webgl_multiple_views.html
        //This function updates the window width and height variables to the actual width and height of the computer
        //regardless of whether the console has been opened or not
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }

        //A function which determines which way the user is moving
        function onDocumentKeyDown(e) {
            movement = 0;
            var keyCode = e.which || e.keyCode; //Gets the key code
            //Sets the direction the user is moving based on which key the user pressed
            if (keyCode == 87) movement = "forward";
            else if (keyCode == 65) movement = "left";
            else if (keyCode == 68) movement = "right";
            else if (keyCode == 83) movement = "backward";
            else if (keyCode == 70) {
                //   console.log("in");
                spotLightOn = !spotLightOn;

                if (spotLightOn == false) {

                    spotLight.intensity = 0;
                    spotLightOn = false;
                }
                else {
                    spotLight.intensity = 1;
                    spotLightOn = true;
                }
            }
            if (movement != 0) moveAround(); //If the user is moving then call the moveAround function
        }

        //Function which moves the user & handles collision
        function moveAround() {

            if (stamina <= 10) {
                speed = 1;
            }
            else if (stamina > 10) {
                speed = 2;
            }
            moving = true; //Sets the boolean whether the user was moving or not to true
            oldCamera = camera.clone(); //Create a clone of the camera
            //Translates the user using a specific speed based on which movement has been triggered
            if (movement == "forward") camera.translateZ(-speed);
            if (movement == "left") camera.translateX(-speed);
            if (movement == "backward") camera.translateZ(speed);
            if (movement == "right") camera.translateX(speed);

            for (let t = 0; t < stars.length; t++) { //For the length of the array containing all of the trees
                if (calcPointDistance(camera.position, stars[t].position) <= 2) { //Calcs whether the camera and a
                    //certain tree are too close together
                    starHit = t; //Sets boolean "hit" to true
                }
            }
            //Src: https://github.com/TovAqulic/threejs_collision_issue
            if (hit == true) { //If the user has collided with a tree then move the user in the opposite direction that
                //the tree they collided with is in
                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);
                hit = false; //Sets the "hit" boolean to false
            }
            //Src: https://github.com/TovAqulic/threejs_collision_issue
            if (starHit != -1) {
                movingStars.push(stars[starHit]);
                stars.splice(starHit, 1);
                starHit = -1; //Sets the "hit" boolean to false
                starsCollected += 1;
                if (starsCollected == 5) {
                    gameOver(1);
                }
            }
            //If the user is out of bounds then move them in the opposite direction of the way they are trying to walk
            else if (camera.position.x < -380 || camera.position.x > 380 || camera.position.z < -380 || camera.position.z > 380) {
                if (movement == "forward") camera.translateZ(speed);
                if (movement == "left") camera.translateX(speed);
                if (movement == "backward") camera.translateZ(-speed);
                if (movement == "right") camera.translateX(-speed);

            }
        };

        function gameOver(state) {
            if (state == 1) {
                //console.log("YOU WON BITCHES!");
            }
            else {
                //  console.log("wahh wahh wahhh");

            }


        }

        document.addEventListener('keydown', onDocumentKeyDown, false); //Adds key handler to the document

        //If the user has not pressed any keys then the boolean determining whether the user is moving should be turned to false
        document.addEventListener('keyup', (event) => {
            moving = false;
        });




        function makeMonster() {
            makeSmoke();
            const geometry = new THREE.SphereGeometry(10, 32, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            return sphere;
        }


        let monster = makeMonster();
        //console.log(camera.position);





        // function calls
        initCursor();
        initWorld();
        makeFoggy();
        createLandAndWater();
        createMoon();

        makeTrees();
        makeStars(5);
        makeBody();
        initFlashLight();

        let positions = [windowWidth - (windowWidth * .78), windowWidth - (windowWidth * .81), windowWidth - (windowWidth * .84)];
        for (let i = 0; i < 3; i++) {
            makeHeart(positions[i]);
            // console.log(heartArray[i]);
        }
        // console.log(positions);



        animate();
        render();


    </script>
</body>

</html>